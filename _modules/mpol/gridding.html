

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mpol.gridding &mdash; MPoL 0.1.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://buttons.github.io/buttons.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/bullets.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/faculty.css" type="text/css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans|Roboto:400,700|Roboto+Mono:400,700&display=swap" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

  
    <a class="heading heading-extra-margin" href="../../index.html">
      <div class="logo-box logo-box-large">
        <img class="logo" src="../../_static/logo.png"/>
      </div>
      
        <span class="icon icon-home"> MPoL</span>
      
    </a>
  

  
    
    
      <div class="version">0.1.1</div>
    
  

  
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rml_intro.html">Introduction to Regularized Maximum Likelihood Imaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">MPoL Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../units-and-conventions.html">Units and Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer-documentation.html">Developer Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ci-tutorials/PyTorch.html">Introduction to PyTorch: Tensors and Gradient Descent</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ci-tutorials/gridder.html">Gridding and diagnostic images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ci-tutorials/optimization.html">Optimization Loop</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ci-tutorials/crossvalidation.html">Cross validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ci-tutorials/gpu_setup.html">GPU Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ci-tutorials/initializedirtyimage.html">Initializing with the Dirty Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../large-tutorials/HD143006_part_1.html">HD143006 Tutorial Part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../large-tutorials/HD143006_part_2.html">HD143006 Tutorial Part 2</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">MPoL</a>
        
      </nav>


      <div class="wy-nav-content">

  

  
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
  <li class="breadcrumb"><a href="../../index.html">MPoL</a> &raquo;</li>
    
      <li class="breadcrumb"><a href="../index.html">Module code</a> &raquo;</li>
    
  <li class="breadcrumb">mpol.gridding</li>

    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mpol.gridding</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.coordinates</span> <span class="kn">import</span> <span class="n">_setup_coords</span>
<span class="kn">from</span> <span class="nn">.datasets</span> <span class="kn">import</span> <span class="n">GriddedDataset</span>


<span class="k">def</span> <span class="nf">_check_data_inputs_2d</span><span class="p">(</span><span class="n">uu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_re</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_im</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that all data inputs are the same shape, the weights are positive, and the data_re and data_im are floats.</span>

<span class="sd">    If the user supplied 1d vectors of shape ``(nvis,)``, make them all 2d with one channel, ``(1,nvis)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">uu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">uu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">),</span> <span class="s2">&quot;Input data vectors should be either 1D or 2D numpy arrays.&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">uu</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">vv</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">data_re</span><span class="p">,</span> <span class="n">data_im</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">shape</span>
        <span class="p">),</span> <span class="s2">&quot;All dataset inputs must be the same input shape and size.&quot;</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">),</span> <span class="s2">&quot;Not all thermal weights are positive, check inputs.&quot;</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">data_re</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">data_re</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
    <span class="p">),</span> <span class="s2">&quot;data_re should be type single or double&quot;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">data_im</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">data_im</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span>
    <span class="p">),</span> <span class="s2">&quot;data_im should be type single or double&quot;</span>

    <span class="k">if</span> <span class="n">uu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">uu</span><span class="p">)</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">data_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data_re</span><span class="p">)</span>
        <span class="n">data_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data_im</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">data_re</span><span class="p">,</span> <span class="n">data_im</span>

    <span class="c1"># expand to 2d with complex conjugates</span>


<div class="viewcode-block" id="Gridder"><a class="viewcode-back" href="../../api.html#mpol.gridding.Gridder">[docs]</a><span class="k">class</span> <span class="nc">Gridder</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Gridder object uses desired image dimensions (via the ``cell_size`` and ``npix`` arguments) to define a corresponding Fourier plane grid as a :class:`.GridCoords` object. A pre-computed :class:`.GridCoords` can be supplied in lieu of ``cell_size`` and ``npix``, but all three arguments should never be supplied at once. For more details on the properties of the grid that is created, see the :class:`.GridCoords` documentation.</span>

<span class="sd">    The :class:`.Gridder` object accepts &quot;loose&quot; *ungridded* visibility data and stores the arrays to the object as instance attributes. The input visibility data should be the set of visibilities over the full :math:`[-u,u]` and :math:`[-v,v]` domain, the Gridder will automatically augment the dataset to include the complex conjugates. The visibilities can be 1d for a single continuum channel, or 2d for image cube. If 1d, visibilities will be converted to 2d arrays of shape ``(1, nvis)``. Like the :class:`~mpol.images.ImageCube` class, after construction, the Gridder assumes that you are operating with a multi-channel set of visibilities. These routines will still work with single-channel &#39;continuum&#39; visibilities, they will just have nchan = 1 in the first dimension of most products.</span>

<span class="sd">    If your goal is to use these gridded visibilities in Regularized Maximum Likelihood imaging, you can export them to the appropriate PyTorch object using the :func:`~mpol.gridding.Gridder.to_pytorch_dataset` routine.</span>

<span class="sd">    If you just want to take a quick look at the rough image plane representation of the visibilities, you can view the &#39;dirty image&#39; and the point spread function or &#39;dirty beam&#39; using the :func:`~mpol.gridding.Gridder.get_dirty_image` and :func:`~mpol.gridding.Gridder.get_dirty_beam` methods.</span>

<span class="sd">    Args:</span>
<span class="sd">        cell_size (float): width of a single square pixel in [arcsec]</span>
<span class="sd">        npix (int): number of pixels in the width of the image</span>
<span class="sd">        coords (GridCoords): an object already instantiated from the GridCoords class. If providing this, cannot provide ``cell_size`` or ``npix``.</span>
<span class="sd">        uu (numpy array): array of u spatial frequency coordinates. Units of [:math:`\mathrm{k}\lambda`]</span>
<span class="sd">        vv (numpy array): (nchan, nvis) length array of v spatial frequency coordinates. Units of [:math:`\mathrm{k}\lambda`]</span>
<span class="sd">        weight (2d numpy array): (nchan, nvis) length array of thermal weights. Units of [:math:`1/\mathrm{Jy}^2`]</span>
<span class="sd">        data_re (2d numpy array): (nchan, nvis) length array of the real part of the visibility measurements. Units of [:math:`\mathrm{Jy}`]</span>
<span class="sd">        data_im (2d numpy array): (nchan, nvis) length array of the imaginary part of the visibility measurements. Units of [:math:`\mathrm{Jy}`]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cell_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">npix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_re</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_im</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># check everything should be 2d, expand if not</span>
        <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">data_re</span><span class="p">,</span> <span class="n">data_im</span> <span class="o">=</span> <span class="n">_check_data_inputs_2d</span><span class="p">(</span>
            <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">data_re</span><span class="p">,</span> <span class="n">data_im</span>
        <span class="p">)</span>

        <span class="c1"># setup the coordinates object</span>
        <span class="n">nchan</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uu</span><span class="p">)</span>
        <span class="n">_setup_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_size</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">nchan</span><span class="p">)</span>

        <span class="c1"># expand the vectors to include complex conjugates</span>
        <span class="n">uu_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">uu</span><span class="p">,</span> <span class="o">-</span><span class="n">uu</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">vv_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">vv</span><span class="p">,</span> <span class="o">-</span><span class="n">vv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># make sure we still fit into the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">check_data_fit</span><span class="p">(</span><span class="n">uu_full</span><span class="p">,</span> <span class="n">vv_full</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">uu</span> <span class="o">=</span> <span class="n">uu_full</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vv</span> <span class="o">=</span> <span class="n">vv_full</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data_re</span><span class="p">,</span> <span class="n">data_re</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data_im</span><span class="p">,</span> <span class="o">-</span><span class="n">data_im</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># figure out which visibility cell each datapoint lands in, so that</span>
        <span class="c1"># we can later assign it the appropriate robust weight for that cell</span>
        <span class="c1"># do this by calculating the nearest cell index [0, N] for all samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">u_chan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">u_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">u_chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">index_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">v_chan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">v_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v_chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vv</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sum_cell_values_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of loose visibility points :math:`(u,v)` and their corresponding values :math:`x`,</span>
<span class="sd">        partition the points up into 2D :math:`u-v` cells defined by the ``coords`` object attached to</span>
<span class="sd">        the gridder, such that ``cell[i,j]`` has bounds between ``coords.u_edges[j, j+1]`` and ``coords.v_edges[i, i+1]``.</span>
<span class="sd">        Then, sum the corresponding values for each :math:`(u,v)` point that falls within each cell. The resulting</span>
<span class="sd">        cell value is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathrm{result}_{i,j} = \sum_k \mathrm{values}_k</span>

<span class="sd">        where :math:`k` indexes all :math:`(u,v)` points that fall within ``coords.u_edges[j, j+1]`` and ``coords.v_edges[i, i+1]``. In the case that all values are :math:`1`, the result is the number of visibilities within each cell (i.e., a histogram).</span>

<span class="sd">        Args:</span>
<span class="sd">            uu (np.array): 1D array of East-West spatial frequency coordinates for a specific channel. Units of [:math:`\mathrm{k}\lambda`]</span>
<span class="sd">            vv (np.array): 1D array of North-South spatial frequency coordinates for a specific channel. Units of [:math:`\mathrm{k}\lambda`]</span>
<span class="sd">            values (np.array): 1D array of values (the same length as uu and vv) to use in the sum over each cell. The default (``values=None``) corresponds to using ``values=np.ones_like(uu)`` such that the routine is equivalent to a histogram.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A 2D array of size ``(npix, npix)`` in ground format containing the summed cell quantities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span>
            <span class="n">vv</span><span class="p">,</span>
            <span class="n">uu</span><span class="p">,</span>
            <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">v_edges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">u_edges</span><span class="p">],</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># only return the &quot;H&quot; value</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_sum_cell_values_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the :func:`~mpol.gridding.Gridder.sum_cell_values_channel` routine over all channels of the</span>
<span class="sd">        input visibilities.</span>

<span class="sd">        Args:</span>
<span class="sd">            values (iterable): ``(nchan, nvis)`` array of values to use in the sum over each cell. The default (``values=None``) corresponds to using ``values=np.ones_like(uu)`` such that the routine is equivalent to a histogram.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A 3D array of size ``(nchan, npix, npix)`` in ground format containing the summed cell quantities.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate the histogrammed result for all channels</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">ncell_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">ncell_u</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># pass None to every channel</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">):</span>
            <span class="n">cube</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_channel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cube</span>

    <span class="k">def</span> <span class="nf">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gridded_quantity</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the gridded cell quantity corresponding to each of the loose visibilities.</span>

<span class="sd">        Args:</span>
<span class="sd">            A 3D array of size ``(nchan, npix, npix)`` in ground format containing the gridded cell quantities.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A ``(nchan, nvis)`` array of values corresponding to the loose visibilities, using the quantity in that cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">gridded_quantity</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">index_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_u</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_grid_visibilities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="n">robust</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">taper_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Grid the loose data visibilities to the Fourier grid in preparation for imaging.</span>

<span class="sd">        Args:</span>
<span class="sd">            weighting (string): The type of cell averaging to perform. Choices of ``&quot;natural&quot;``, ``&quot;uniform&quot;``, or ``&quot;briggs&quot;``, following CASA tclean. If ``&quot;briggs&quot;``, also specify a robust value.</span>
<span class="sd">            robust (float): If ``weighting=&#39;briggs&#39;``, specify a robust value in the range [-2, 2]. ``robust=-2`` approxmately corresponds to uniform weighting and ``robust=2`` approximately corresponds to natural weighting.</span>
<span class="sd">            taper_function (function reference): a function assumed to be of the form :math:`f(u,v)` which calculates a prefactor in the range :math:`[0,1]` and premultiplies the visibility data. The function must assume that :math:`u` and :math:`v` will be supplied in units of :math:`\mathrm{k}\lambda`. By default no taper is applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">taper_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tapering_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tapering_weight</span> <span class="o">=</span> <span class="n">taper_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vv</span><span class="p">)</span>

        <span class="c1"># create the cells as edges around the existing points</span>
        <span class="c1"># note that at this stage, the UV grid is strictly increasing</span>
        <span class="c1"># when in fact, later on, we&#39;ll need to fftshift for the FFT</span>
        <span class="n">cell_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

        <span class="c1"># boolean index for cells that *contain* visibilities</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">cell_weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="c1"># calculate the density weights</span>
        <span class="c1"># the density weights have the same shape as the re, im samples.</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;natural&quot;</span><span class="p">:</span>
            <span class="n">density_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="c1"># cell_weight is (nchan, ncell_v, ncell_u)</span>
            <span class="c1"># self.index_v, self.index_u are (nchan, nvis)</span>
            <span class="c1"># we want density_weights to be (nchan, nvis)</span>
            <span class="n">density_weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="n">cell_weight</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;briggs&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">robust</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If &#39;briggs&#39; weighting, a robust value must be specified between [-2, 2].&quot;</span>
                <span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">robust</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">robust</span> <span class="o">&lt;=</span> <span class="mi">2</span>
            <span class="p">),</span> <span class="s2">&quot;robust parameter must be in the range [-2, 2]&quot;</span>

            <span class="c1"># implement robust weighting using the definition used in CASA</span>
            <span class="c1"># https://casa.nrao.edu/casadocs-devel/stable/imaging/synthesis-imaging/data-weighting</span>

            <span class="c1"># calculate the robust parameter f^2 for each channel</span>
            <span class="n">f_sq</span> <span class="o">=</span> <span class="p">((</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">robust</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cell_weight</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># the robust weight corresponding to the cell</span>
            <span class="n">cell_robust_weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cell_weight</span> <span class="o">*</span> <span class="n">f_sq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

            <span class="c1"># zero out cells that have no visibilities</span>
            <span class="c1"># to prevent normalization error in next step</span>
            <span class="n">cell_robust_weight</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># now assign the cell robust weight to each visibility within that cell</span>
            <span class="n">density_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="n">cell_robust_weight</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;weighting must be specified as one of &#39;natural&#39;, &#39;uniform&#39;, or &#39;briggs&#39;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># the factor of 2 in the denominator is needed because</span>
        <span class="c1"># we are approximating the Eqn 3.8 of Briggs&#39; thesis</span>
        <span class="c1"># we need to sum over the Hermitian quantities in the</span>
        <span class="c1"># normalization constant.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tapering_weight</span> <span class="o">*</span> <span class="n">density_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># grid the reals and imaginaries separately</span>
        <span class="c1"># outputs from _sum_cell_values_cube are *not* pre-packed</span>
        <span class="n">data_re_gridded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_re</span> <span class="o">*</span> <span class="n">tapering_weight</span> <span class="o">*</span> <span class="n">density_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
        <span class="p">)</span>

        <span class="n">data_im_gridded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_im</span> <span class="o">*</span> <span class="n">tapering_weight</span> <span class="o">*</span> <span class="n">density_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
        <span class="p">)</span>

        <span class="c1"># the beam is the response to a point source, which is data_re = constant, data_im = 0</span>
        <span class="c1"># so we save time and only calculate the reals, because gridded_beam_im = 0</span>
        <span class="n">re_gridded_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span>
            <span class="n">tapering_weight</span> <span class="o">*</span> <span class="n">density_weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
        <span class="p">)</span>

        <span class="c1"># store the pre-packed FFT products for access by outside routines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_re_gridded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">data_re_gridded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_im_gridded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">data_im_gridded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis_gridded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_re_gridded</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_im_gridded</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">j</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">re_gridded_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">re_gridded_beam</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_grid_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average the visibility weights to the Fourier grid contained in ``self.coords``, such that</span>
<span class="sd">        the ``self.weight_gridded`` corresponds to the equivalent weight on the averaged visibilities</span>
<span class="sd">        within that cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create the cells as edges around the existing points</span>
        <span class="c1"># note that at this stage, the UV grid is strictly increasing</span>
        <span class="c1"># when in fact, later on, we&#39;ll need to fftshift for the FFT</span>
        <span class="n">cell_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

        <span class="c1"># instantiate uncertainties for each averaged visibility.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_gridded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">cell_weight</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_estimate_cell_standard_deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the `standard deviation &lt;https://en.wikipedia.org/wiki/Standard_deviation&gt;`__ of the real and imaginary visibility values within each :math:`u,v` cell (:math:`\mathrm{cell}_{i,j}`) defined by ``self.coords`` using the following steps.</span>

<span class="sd">        1. Calculate the mean real :math:`\mu_\Re` and imaginary :math:`\mu_\Im` values within each cell using a weighted mean, assuming that the visibility function is constant across the cell.</span>
<span class="sd">        2. For each visibility :math:`k` that falls within the cell, calculate the real and imaginary residuals (:math:`r_\Re` and :math:`r_\Im`) in units of :math:`\sigma_k`, where :math:`\sigma_k = \sqrt{1/w_k}` and :math:`w_k` is the weight of that visibility.</span>
<span class="sd">        3. Calculate the standard deviation :math:`s_{i,j}` of the residual distributions within each cell</span>

<span class="sd">        .. math::</span>

<span class="sd">            s_{i,j} = \sqrt{\frac{1}{N} \sum_k \left (\sigma_k - \bar{\sigma}_{i,j} \right )^2}</span>

<span class="sd">        where :math:`\bar{\sigma}_{i,j}` is first estimated as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \bar{\sigma}_{i,j} = \frac{1}{N} \sum_k \sigma_k</span>


<span class="sd">        Returns:</span>
<span class="sd">            std_real, std_imag: two 3D arrays of size ``(nchan, npix, npix)`` in ground format containing the standard deviation of the real and imaginary values within each cell, in units of :math:`\sigma`. If everything is correctly calibrated, we expect :math:`s_{i,j} \approx 1 \forall i,j`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1. use the gridding routine to calculate the mean real and imaginary values on the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_visibilities</span><span class="p">(</span><span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">)</span>

        <span class="c1"># convert grid back to ground format</span>
        <span class="n">mu_re_gridded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_re_gridded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">mu_im_gridded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_im_gridded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># extract the real and imaginary values corresponding to the &quot;loose&quot; visibilities</span>
        <span class="c1"># mu_re_gridded and mu_im_gridded are arrays with shape (nchan, ncell_v, ncell_u)</span>
        <span class="c1"># self.index_v, self.index_u are (nchan, nvis)</span>
        <span class="c1"># we want mu_re and mu_im to be (nchan, nvis)</span>
        <span class="n">mu_re</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="n">mu_re_gridded</span><span class="p">)</span>
        <span class="n">mu_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="n">mu_im_gridded</span><span class="p">)</span>

        <span class="c1"># 2. calculate the real and imaginary residuals for the loose visibilities</span>
        <span class="c1"># 1/sigma = np.sqrt(weight)</span>
        <span class="n">residual_re</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_re</span> <span class="o">-</span> <span class="n">mu_re</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">residual_im</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_im</span> <span class="o">-</span> <span class="n">mu_im</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

        <span class="c1"># 3. calculate the standard deviation of the residual visibilities</span>

        <span class="c1"># 3.1 first calculate the mean residuals</span>
        <span class="c1"># calculate the number of visibilities with each cell</span>
        <span class="n">nvis_cell_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">()</span>
        <span class="c1"># extract this out as a quantity for each visibility</span>
        <span class="n">nvis_cell_loose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="n">nvis_cell_grid</span><span class="p">)</span>

        <span class="c1"># calculate the mean residuals</span>
        <span class="c1"># sum residual values</span>
        <span class="n">bar_sigma_re</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span><span class="n">residual_re</span> <span class="o">/</span> <span class="n">nvis_cell_loose</span><span class="p">)</span>
        <span class="n">bar_sigma_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span><span class="n">residual_im</span> <span class="o">/</span> <span class="n">nvis_cell_loose</span><span class="p">)</span>
        <span class="c1"># extract back to loose</span>
        <span class="n">bar_sigma_re_loose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="n">bar_sigma_re</span><span class="p">)</span>
        <span class="n">bar_sigma_im_loose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_gridded_values_to_loose</span><span class="p">(</span><span class="n">bar_sigma_im</span><span class="p">)</span>

        <span class="c1"># 3.2 calculate the standard deviation of the residuals</span>
        <span class="n">s_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span>
                <span class="p">(</span><span class="n">residual_re</span> <span class="o">-</span> <span class="n">bar_sigma_re_loose</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">nvis_cell_loose</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">s_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_cell_values_cube</span><span class="p">(</span>
                <span class="p">(</span><span class="n">residual_im</span> <span class="o">-</span> <span class="n">bar_sigma_im_loose</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">nvis_cell_loose</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">s_re</span><span class="p">,</span> <span class="n">s_im</span>

    <span class="k">def</span> <span class="nf">_check_scatter_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_scatter</span><span class="o">=</span><span class="mf">1.2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks/compares visibility scatter to a given threshold value ``max_scatter`` and raises an AssertionError if the median scatter across all cells exceeds ``max_scatter``.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_scatter (float): the maximum permissible scatter in units of standard deviation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a dictionary containing keys ``return_status``, ``median_re``, and ``median_im``. ``return_status`` is a boolean that is ``False`` if scatter is within acceptable limits of max_scatter (good), and is ``True`` if scatter exceeds acceptable limits. ``median_re`` and ``median_im`` are the median scatter values returned across all cells, in units of standard deviation (estimated from the provided weights).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s_re</span><span class="p">,</span> <span class="n">s_im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_cell_standard_deviation</span><span class="p">()</span>

        <span class="n">median_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">s_re</span><span class="p">[</span><span class="n">s_re</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">median_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">s_im</span><span class="p">[</span><span class="n">s_im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">return_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">median_re</span> <span class="o">&gt;</span> <span class="n">max_scatter</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">median_im</span> <span class="o">&gt;</span> <span class="n">max_scatter</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;return_status&quot;</span><span class="p">:</span> <span class="n">return_status</span><span class="p">,</span>
            <span class="s2">&quot;median_re&quot;</span><span class="p">:</span> <span class="n">median_re</span><span class="p">,</span>
            <span class="s2">&quot;median_im&quot;</span><span class="p">:</span> <span class="n">median_im</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_fliplr_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cube</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_dirty_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">re_gridded_beam</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the dirty beam corresponding to the gridded visibilities.</span>

<span class="sd">        Args:</span>
<span class="sd">            C (1D np.array): normalization constants for each channel</span>
<span class="sd">            re_gridded_beam (3d np.array): the gridded visibilities corresponding to a unit point source in the center of the field.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy image cube with a dirty beam (PSF) for each channel. By definition, the peak is normalized to 1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if we&#39;re sticking to the dirty beam and image equations in Briggs&#39; Ph.D. thesis,</span>
        <span class="c1"># no correction for du or dv prefactors needed here</span>
        <span class="c1"># that is because we are using the FFT to compute an already discretized equation, not</span>
        <span class="c1"># approximating a continuous equation.</span>

        <span class="n">beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fliplr_cube</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">npix</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span>
                    <span class="n">C</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">re_gridded_beam</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
        <span class="p">),</span> <span class="s2">&quot;Dirty beam contained substantial imaginary values, check input visibilities, otherwise raise a github issue.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">beam</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">real</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam</span>

    <span class="k">def</span> <span class="nf">_null_dirty_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ntheta</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">single_channel_estimate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Zero out (null) all pixels in the dirty beam exterior to the first null, for each channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            ntheta (int): number of azimuthal wedges to use for the 1st null calculation. More wedges will result in a more accurate estimate of dirty beam area, but will also take longer.</span>
<span class="sd">            single_channel_estimate (bool): If ``True`` (the default), use the area estimated from the first channel for all channels in the multi-channel image cube. If ``False``, calculate the beam area for all channels.</span>

<span class="sd">        Returns: a cube like the dirty beam, but with all pixels exterior to the first null set to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_dirty_beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_gridded_beam</span><span class="p">)</span>

        <span class="c1"># consider the 2D beam for each channel described by polar coordinates r, theta.</span>
        <span class="c1">#</span>
        <span class="c1"># this routine works by finding the smallest r for which the beam goes negative (the first null)</span>
        <span class="c1"># as a function of theta. Then, for this same theta, all pixels (negative or not) with values of r larger than</span>
        <span class="c1"># this are set to 0.</span>

        <span class="c1"># the end product of this routine will be a &quot;nulled&quot; beam, which can be used in the calculation</span>
        <span class="c1"># of dirty beam area.</span>

        <span class="c1"># the angular extent for each &quot;slice&quot;</span>
        <span class="c1"># the smaller the slice, the more accurate the area estimate, but also the</span>
        <span class="c1"># longer it takes</span>
        <span class="n">da</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">ntheta</span>  <span class="c1"># radians</span>
        <span class="n">azimuths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">da</span><span class="p">)</span>

        <span class="c1"># calculate a meshgrid (same for all channels)</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">l_centers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">m_centers</span><span class="p">)</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ll</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">mm</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ll</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># radians in range [0, 2pi]</span>

        <span class="n">nulled_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># for each channel,</span>
        <span class="c1"># find the first occurrence of a non-zero value, such that we end up with a continuous</span>
        <span class="c1"># ring of masked values.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">):</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="n">nulled_beam</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ind_neg</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">&lt;</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">azimuths</span><span class="p">:</span>
                <span class="c1"># examine values between a, a+da with some overlap</span>
                <span class="n">ind_azimuth</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&gt;=</span> <span class="n">a</span> <span class="o">-</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">da</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mf">1.3</span> <span class="o">*</span> <span class="n">da</span><span class="p">))</span>

                <span class="c1"># find all negative values within azimuth slice</span>
                <span class="n">ind_neg_and_az</span> <span class="o">=</span> <span class="n">ind_neg</span> <span class="o">&amp;</span> <span class="n">ind_azimuth</span>

                <span class="c1"># find the smallest r within this slice</span>
                <span class="n">min_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rr</span><span class="p">[</span><span class="n">ind_neg_and_az</span><span class="p">])</span>

                <span class="c1"># null all pixels within this slice with radii r or greater</span>
                <span class="n">ind_r</span> <span class="o">=</span> <span class="n">rr</span> <span class="o">&gt;=</span> <span class="n">min_r</span>
                <span class="n">ind_r_and_az</span> <span class="o">=</span> <span class="n">ind_r</span> <span class="o">&amp;</span> <span class="n">ind_azimuth</span>
                <span class="n">nb</span><span class="p">[</span><span class="n">ind_r_and_az</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">single_channel_estimate</span><span class="p">:</span>
                <span class="c1"># just copy the mask from the first channel to all channels</span>
                <span class="n">ind_0</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">nulled_beam</span><span class="p">[:,</span> <span class="n">ind_0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">nulled_beam</span>

<div class="viewcode-block" id="Gridder.get_dirty_beam_area"><a class="viewcode-back" href="../../api.html#mpol.gridding.Gridder.get_dirty_beam_area">[docs]</a>    <span class="k">def</span> <span class="nf">get_dirty_beam_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ntheta</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">single_channel_estimate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the effective area of the dirty beam for each channel. Assumes that the beam has already been generated by running :func:`~mpol.gridding.Gridder.get_dirty_image`. This is an approximate calculation involving a simple sum over all pixels out to the first null (zero crossing) of the dirty beam. This quantity is designed to approximate the conversion of image units from :math:`[\mathrm{Jy}\,\mathrm{beam}^{-1}]` to :math:`[\mathrm{Jy}\,\mathrm{arcsec}^{-2}]`, even though units of :math:`[\mathrm{Jy}\,\mathrm{dirty\;beam}^{-1}]` are technically undefined.</span>

<span class="sd">        Args:</span>
<span class="sd">            ntheta (int): number of azimuthal wedges to use for the 1st null calculation. More wedges will result in a more accurate estimate of dirty beam area, but will also take longer.</span>
<span class="sd">            single_channel_estimate (bool): If ``True`` (the default), use the area estimated from the first channel for all channels in the multi-channel image cube. If ``False``, calculate the beam area for all channels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (1D numpy array float) beam area for each channel in units of :math:`[\mathrm{arcsec}^{2}]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nulled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_dirty_beam</span><span class="p">(</span>
            <span class="n">ntheta</span><span class="o">=</span><span class="n">ntheta</span><span class="p">,</span> <span class="n">single_channel_estimate</span><span class="o">=</span><span class="n">single_channel_estimate</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">cell_size</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nulled</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># arcsec^2</span></div>

<div class="viewcode-block" id="Gridder.get_dirty_image"><a class="viewcode-back" href="../../api.html#mpol.gridding.Gridder.get_dirty_image">[docs]</a>    <span class="k">def</span> <span class="nf">get_dirty_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
        <span class="n">robust</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">taper_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;Jy/beam&quot;</span><span class="p">,</span>
        <span class="n">check_visibility_scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_scatter</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
        <span class="o">**</span><span class="n">beam_kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the dirty image.</span>

<span class="sd">        Args:</span>
<span class="sd">            weighting (string): The type of cell averaging to perform. Choices of ``&quot;natural&quot;``, ``&quot;uniform&quot;``, or ``&quot;briggs&quot;``, following CASA tclean. If ``&quot;briggs&quot;``, also specify a robust value.</span>
<span class="sd">            robust (float): If ``weighting=&#39;briggs&#39;``, specify a robust value in the range [-2, 2]. ``robust=-2`` approxmately corresponds to uniform weighting and ``robust=2`` approximately corresponds to natural weighting.</span>
<span class="sd">            taper_function (function reference): a function assumed to be of the form :math:`f(u,v)` which calculates a prefactor in the range :math:`[0,1]` and premultiplies the visibility data. The function must assume that :math:`u` and :math:`v` will be supplied in units of :math:`\mathrm{k}\lambda`. By default no taper is applied.</span>
<span class="sd">            unit (string): what unit should the image be in. Default is ``&quot;Jy/beam&quot;``. If ``&quot;Jy/arcsec^2&quot;``, then the effective area of the dirty beam will be used to convert from ``&quot;Jy/beam&quot;`` to ``&quot;Jy/arcsec^2&quot;``.</span>
<span class="sd">            check_visibility_scatter (bool): whether the routine should check the standard deviation of visibilities in each within each :math:`u,v` cell (:math:`\mathrm{cell}_{i,j}`) defined by ``self.coords``. Default is ``True``. A ``RuntimeWarning`` will be raised if any cell has a scatter larger than ``max_scatter``.</span>
<span class="sd">            max_scatter (float): the maximum allowable standard deviation of visibility values in a given :math:`u,v` cell (:math:`\mathrm{cell}_{i,j}`) defined by ``self.coords``. Defaults to a factor of 120%.</span>
<span class="sd">            **beam_kwargs: all additional keyword arguments passed to :func:`~mpol.gridding.get_dirty_beam_area` if ``unit=&quot;Jy/arcsec^2&quot;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2-tuple of (``image``, ``beam``) where ``image`` is an (nchan, npix, npix) numpy array of the dirty image cube in units ``unit``. ``beam`` is an numpy image cube with a dirty beam (PSF) for each channel. The units of the beam are always Jy/{dirty beam}, i.e., the peak of the beam is normalized to 1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check unit input</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Jy/beam&quot;</span><span class="p">,</span> <span class="s2">&quot;Jy/arcsec^2&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown unit&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

        <span class="c1"># check the visibility scatter and flag user if there are issues</span>
        <span class="k">if</span> <span class="n">check_visibility_scatter</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_scatter_error</span><span class="p">(</span><span class="n">max_scatter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;return_status&quot;</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="ne">RuntimeWarning</span><span class="p">(</span>
                        <span class="s2">&quot;Visibility scatter exceeds ``max_scatter``:</span><span class="si">{:}</span><span class="s2">, indicating a potential problem with data weights. Consider inspecting weights using CASA tools before exporting visibilities for use with MPoL. Median real scatter: </span><span class="si">{:}</span><span class="s2"> x sigma. Median imag scatter: </span><span class="si">{:}</span><span class="s2"> x sigma.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">max_scatter</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;median_re&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;median_im&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># call _grid_visibilities</span>
        <span class="c1"># inputs for weighting will be checked inside _grid_visibilities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_visibilities</span><span class="p">(</span>
            <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">,</span>
            <span class="n">robust</span><span class="o">=</span><span class="n">robust</span><span class="p">,</span>
            <span class="n">taper_function</span><span class="o">=</span><span class="n">taper_function</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fliplr_cube</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">npix</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis_gridded</span><span class="p">),</span>
                <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># Jy/beam</span>

        <span class="c1"># calculate the beam</span>
        <span class="c1"># also pre-stores internal self.beam value for area routine, if necessary</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dirty_beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_gridded_beam</span><span class="p">)</span>

        <span class="c1"># for units of Jy/arcsec^2, we could just leave out the C constant *if* we were doing</span>
        <span class="c1"># uniform weighting. The relationships get more complex for robust or natural weighting, however,</span>
        <span class="c1"># so it&#39;s safer to calculate the number of arcseconds^2 per beam</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;Jy/arcsec^2&quot;</span><span class="p">:</span>
            <span class="n">beam_area_per_chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dirty_beam_area</span><span class="p">(</span><span class="o">**</span><span class="n">beam_kwargs</span><span class="p">)</span>  <span class="c1"># [arcsec^2]</span>

            <span class="c1"># convert image</span>
            <span class="c1"># (Jy/1 arcsec^2) = (Jy/ 1 beam) * (1 beam/ n arcsec^2)</span>
            <span class="c1"># beam_area_per_chan is the n of arcsec^2 per 1 beam</span>

            <span class="n">img</span> <span class="o">/=</span> <span class="n">beam_area_per_chan</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
        <span class="p">),</span> <span class="s2">&quot;Dirty image contained substantial imaginary values, check input visibilities, otherwise raise a github issue.&quot;</span>

        <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">beam</span></div>

<div class="viewcode-block" id="Gridder.to_pytorch_dataset"><a class="viewcode-back" href="../../api.html#mpol.gridding.Gridder.to_pytorch_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">to_pytorch_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check_visibility_scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_scatter</span><span class="o">=</span><span class="mf">1.2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export gridded visibilities to a PyTorch dataset object.</span>

<span class="sd">        Args:</span>
<span class="sd">            check_visibility_scatter (bool): whether the routine should check the standard deviation of visibilities in each within each :math:`u,v` cell (:math:`\mathrm{cell}_{i,j}`) defined by ``self.coords``. Default is ``True``. A ``RuntimeError`` will be raised if any cell has a scatter larger than ``max_scatter``.</span>
<span class="sd">            max_scatter (float): the maximum allowable standard deviation of visibility values in a given :math:`u,v` cell (:math:`\mathrm{cell}_{i,j}`) defined by ``self.coords``. Defaults to a factor of 120%.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`~mpol.datasets.GriddedDataset` with gridded visibilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check the visibility scatter and flag user if there are issues</span>
        <span class="k">if</span> <span class="n">check_visibility_scatter</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_scatter_error</span><span class="p">(</span><span class="n">max_scatter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;return_status&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Visibility scatter exceeds ``max_scatter``:</span><span class="si">{:}</span><span class="s2">, indicating a potential problem with data weights. Consider inspecting weights using CASA tools before exporting visibilities for use with MPoL. Median real scatter: </span><span class="si">{:}</span><span class="s2"> x sigma. Median imag scatter: </span><span class="si">{:}</span><span class="s2"> x sigma.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">max_scatter</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;median_re&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;median_im&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># grid visibilites (uniform weighting necessary here) and weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_visibilities</span><span class="p">(</span><span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_weights</span><span class="p">()</span>

        <span class="c1"># This should be an obsolete check now but I&#39;ll leave it here for now</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight_gridded</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;To export with uncertainties, first grid visibilities with weighting=&#39;uniform&#39;, no tapering function, and robust=None. Otherwise, data weights are not defined.&quot;</span>

        <span class="k">return</span> <span class="n">GriddedDataset</span><span class="p">(</span>
            <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">nchan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchan</span><span class="p">,</span>
            <span class="n">vis_gridded</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vis_gridded</span><span class="p">,</span>
            <span class="n">weight_gridded</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_gridded</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ground_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The visibility FFT cube fftshifted for plotting with ``imshow``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (torch.complex tensor, of shape ``(nchan, npix, npix)``): the FFT of the image cube, in sky plane format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis_gridded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-21, Ian Czekala

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>


      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-5472810-8', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>
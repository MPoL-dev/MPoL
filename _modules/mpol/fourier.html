
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mpol.fourier &#8212; MPoL 0.1.13 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="https://buttons.github.io/buttons.js"></script>
    <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">MPoL 0.1.13 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  User Guide
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../rml_intro.html">
   Introduction to Regularized Maximum Likelihood Imaging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../installation.html">
   MPoL Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../units-and-conventions.html">
   Units and Conventions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../developer-documentation.html">
   Developer Documentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../api.html">
   API
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/PyTorch.html">
   Introduction to PyTorch: Tensors and Gradient Descent
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/gridder.html">
   Gridding and diagnostic images
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/optimization.html">
   Intro to RML with MPoL
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/loose-visibilities.html">
   Likelihood functions and model visibilities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/crossvalidation.html">
   Cross validation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/gpu_setup.html">
   GPU Acceleration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/initializedirtyimage.html">
   Initializing with the Dirty Image
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../large-tutorials/HD143006_part_1.html">
   HD143006 Tutorial Part 1
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../large-tutorials/HD143006_part_2.html">
   HD143006 Tutorial Part 2
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../ci-tutorials/fakedata.html">
   Making a Mock Dataset
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../large-tutorials/pyro.html">
   Parametric Inference with Pyro
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../changelog.html">
   Changelog
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/MPoL-dev/MPoL"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for mpol.fourier</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The ``fourier`` module provides the core functionality of MPoL via :class:`mpol.fourier.FourierCube`.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.fft</span>  <span class="c1"># to avoid conflicts with old torch.fft *function*</span>
<span class="kn">import</span> <span class="nn">torchkbnufft</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.coordinates</span> <span class="kn">import</span> <span class="n">GridCoords</span>


<div class="viewcode-block" id="FourierCube"><a class="viewcode-back" href="../../api.html#mpol.fourier.FourierCube">[docs]</a><span class="k">class</span> <span class="nc">FourierCube</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This layer performs the FFT of an ImageCube and stores the corresponding dense FFT output as a cube. If you are using this layer in a forward-modeling RML workflow, because the FFT of the model is essentially stored as a grid, you will need to make the loss function calculation using a gridded loss function (e.g., :func:`mpol.losses.nll_gridded`) and a gridded dataset (e.g., :class:`mpol.datasets.GriddedDataset`).</span>

<span class="sd">    Args:</span>
<span class="sd">        cell_size (float): the width of an image-plane pixel [arcseconds]</span>
<span class="sd">        npix (int): the number of pixels per image side</span>
<span class="sd">        coords (GridCoords): an object already instantiated from the GridCoords class. If providing this, cannot provide ``cell_size`` or ``npix``.</span>
<span class="sd">        persistent_vis (Boolean): should the visibility cube be stored as part of the modules `state_dict`? If `True`, the state of the UV grid will be stored. It is recommended to use `False` for most applications, since the visibility cube will rarely be a direct parameter of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">npix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">persistent_vis</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># we don&#39;t want to bother with the nchan argument here, so</span>
        <span class="c1"># we don&#39;t use the convenience method _setup_coords</span>
        <span class="c1"># and just do it manually</span>
        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">npix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cell_size</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;npix and cell_size must be empty if precomputed GridCoords are supplied.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span>

        <span class="k">elif</span> <span class="n">npix</span> <span class="ow">or</span> <span class="n">cell_size</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;GridCoords must be empty if npix and cell_size are supplied.&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">GridCoords</span><span class="p">(</span><span class="n">cell_size</span><span class="o">=</span><span class="n">cell_size</span><span class="p">,</span> <span class="n">npix</span><span class="o">=</span><span class="n">npix</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">persistent</span><span class="o">=</span><span class="n">persistent_vis</span><span class="p">)</span>

<div class="viewcode-block" id="FourierCube.forward"><a class="viewcode-back" href="../../api.html#mpol.fourier.FourierCube.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the FFT of the image cube on each channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            cube (torch.double tensor, of shape ``(nchan, npix, npix)``): a prepacked image cube, for example, from ImageCube.forward()</span>

<span class="sd">        Returns:</span>
<span class="sd">            (torch.complex tensor, of shape ``(nchan, npix, npix)``): the FFT of the image cube, in packed format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure the cube is 3D</span>
        <span class="k">assert</span> <span class="n">cube</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;cube must be 3D&quot;</span>

        <span class="c1"># the self.cell_size prefactor (in arcsec) is to obtain the correct output units</span>
        <span class="c1"># since it needs to correct for the spacing of the input grid.</span>
        <span class="c1"># See MPoL documentation and/or TMS Eqn A8.18 for more information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">cell_size</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vis</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ground_vis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The visibility cube in ground format cube fftshifted for plotting with ``imshow``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (torch.complex tensor, of shape ``(nchan, npix, npix)``): the FFT of the image cube, in sky plane format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">packed_cube_to_ground_cube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ground_amp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The amplitude of the cube, arranged in unpacked format corresponding to the FFT of the sky_cube. Array dimensions for plotting given by ``self.coords.vis_ext``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.double : 3D amplitude cube of shape ``(nchan, npix, npix)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ground_vis</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ground_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The phase of the cube, arranged in unpacked format corresponding to the FFT of the sky_cube. Array dimensions for plotting given by ``self.coords.vis_ext``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.double : 3D phase cube of shape ``(nchan, npix, npix)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ground_vis</span><span class="p">)</span></div>


<div class="viewcode-block" id="safe_baseline_constant_meters"><a class="viewcode-back" href="../../api.html#mpol.fourier.safe_baseline_constant_meters">[docs]</a><span class="k">def</span> <span class="nf">safe_baseline_constant_meters</span><span class="p">(</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">uv_cell_frac</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine determines whether the baselines can safely be assumed to be constant with channel when they converted from meters to units of kilolambda.</span>

<span class="sd">    The antenna baselines *are* the same as a function of channel when they are measured in physical distance units, such as meters. However, when these baselines are converted to spatial frequency units, via</span>

<span class="sd">    .. math::</span>

<span class="sd">        u = \frac{D}{\lambda},</span>

<span class="sd">    it&#39;s possible that the :math:`u` and :math:`v` values of each channel are significantly different if the :math:`\lambda` values of each channel are significantly different. This routine evaluates whether the maximum change in :math:`u` or :math:`v` across channels (when represented in kilolambda) is smaller than some threshold value, calculated as the fraction of a :math:`u,v` cell defined by ``coords``.</span>

<span class="sd">    If this function returns ``True``, then it would be safe to proceed with parallelization in the :class:`mpol.fourier.NuFFT` layer via the coil dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        uu (1D np.array): a 1D array of length ``nvis`` array of the u (East-West) spatial frequency coordinate in units of [m]</span>
<span class="sd">        vv (1D np.array): a 1D array of length ``nvis`` array of the v (North-South) spatial frequency coordinate in units of [m]</span>
<span class="sd">        freqs (1D np.array): a 1D array of length ``nchan`` of the channel frequencies, in units of [Hz].</span>
<span class="sd">        coords: a :class:`mpol.coordinates.GridCoords` object which represents the image and uv-grid dimensions.</span>
<span class="sd">        uv_cell_frac (float): the maximum threshold for a change in :math:`u` or :math:`v` spatial frequency across channels, measured as a fraction of the :math:`u,v` cell defined by ``coords``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        boolean: `True` if it is safe to assume that the baselines are constant with channel (at a tolerance of ``uv_cell_frac``.) Otherwise returns `False`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># broadcast and convert baselines to kilolambda across channel</span>
    <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">broadcast_and_convert_baselines</span><span class="p">(</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">freqs</span><span class="p">)</span>
    <span class="c1"># should be (nchan, nvis) arrays</span>

    <span class="c1"># convert uv_cell_frac to a kilolambda threshold</span>
    <span class="n">delta_uv</span> <span class="o">=</span> <span class="n">uv_cell_frac</span> <span class="o">*</span> <span class="n">coords</span><span class="o">.</span><span class="n">du</span>  <span class="c1"># [klambda]</span>

    <span class="c1"># find maximum change in baseline across channel</span>
    <span class="c1"># concatenate arrays to save steps</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">])</span>  <span class="c1"># (2, nchan, nvis) arrays</span>

    <span class="c1"># find max - min along channel axis</span>
    <span class="n">uv_min</span> <span class="o">=</span> <span class="n">uv</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">uv_max</span> <span class="o">=</span> <span class="n">uv</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">uv_diff</span> <span class="o">=</span> <span class="n">uv_max</span> <span class="o">-</span> <span class="n">uv_min</span>

    <span class="c1"># find maximum of that</span>
    <span class="n">max_diff</span> <span class="o">=</span> <span class="n">uv_diff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># compare to uv_cell_frac</span>
    <span class="k">return</span> <span class="n">max_diff</span> <span class="o">&lt;</span> <span class="n">delta_uv</span></div>


<div class="viewcode-block" id="safe_baseline_constant_kilolambda"><a class="viewcode-back" href="../../api.html#mpol.fourier.safe_baseline_constant_kilolambda">[docs]</a><span class="k">def</span> <span class="nf">safe_baseline_constant_kilolambda</span><span class="p">(</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">uv_cell_frac</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine determines whether the baselines can safely be assumed to be constant with channel, when the are represented in units of kilolambda.</span>

<span class="sd">    Compared to :class:`mpol.fourier.safe_baseline_constant_meters`, this function works with multidimensional arrays of ``uu`` and ``vv`` that are shape (nchan, nvis) and have units of kilolambda.</span>

<span class="sd">    If this routine returns True, then it should be safe for the user to either average the baselines across channel or simply choose a single, representative channel. This would enable parallelization in the {class}`mpol.fourier.NuFFT` via the coil dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        uu (1D np.array): a 1D array of length ``nvis`` array of the u (East-West) spatial frequency coordinate in units of [m]</span>
<span class="sd">        vv (1D np.array): a 1D array of length ``nvis`` array of the v (North-South) spatial frequency coordinate in units of [m]</span>
<span class="sd">        freqs (1D np.array): a 1D array of length ``nchan`` of the channel frequencies, in units of [Hz].</span>
<span class="sd">        coords: a :class:`mpol.coordinates.GridCoords` object which represents the image and uv-grid dimensions.</span>
<span class="sd">        uv_cell_frac (float): the maximum threshold for a change in :math:`u` or :math:`v` spatial frequency across channels, measured as a fraction of the :math:`u,v` cell defined by ``coords``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        boolean: `True` if it is safe to assume that the baselines are constant with channel (at a tolerance of ``uv_cell_frac``.) Otherwise returns `False`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert uv_cell_frac to a kilolambda threshold</span>
    <span class="n">delta_uv</span> <span class="o">=</span> <span class="n">uv_cell_frac</span> <span class="o">*</span> <span class="n">coords</span><span class="o">.</span><span class="n">du</span>  <span class="c1"># [klambda]</span>

    <span class="c1"># find maximum change in baseline across channel</span>
    <span class="c1"># concatenate arrays to save steps</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">])</span>  <span class="c1"># (2, nchan, nvis) arrays</span>

    <span class="c1"># find max - min along channel axis</span>
    <span class="n">uv_min</span> <span class="o">=</span> <span class="n">uv</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">uv_max</span> <span class="o">=</span> <span class="n">uv</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">uv_diff</span> <span class="o">=</span> <span class="n">uv_max</span> <span class="o">-</span> <span class="n">uv_min</span>

    <span class="c1"># find maximum of that</span>
    <span class="n">max_diff</span> <span class="o">=</span> <span class="n">uv_diff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># compare to uv_cell_frac</span>
    <span class="k">return</span> <span class="n">max_diff</span> <span class="o">&lt;</span> <span class="n">delta_uv</span></div>


<div class="viewcode-block" id="NuFFT"><a class="viewcode-back" href="../../api.html#mpol.fourier.NuFFT">[docs]</a><span class="k">class</span> <span class="nc">NuFFT</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This layer translates input from an :class:`mpol.images.ImageCube` directly to loose, ungridded samples of the Fourier plane, directly corresponding to the :math:`u,v` locations of the data. This layer is different than a :class:`mpol.Fourier.FourierCube` in that, rather than producing the dense cube-like output from an FFT routine, it utilizes the non-uniform FFT or &#39;NuFFT&#39; to interpolate directly to discrete :math:`u,v` locations that need not correspond to grid cell centers. This is implemented using the KbNufft routines of the `TorchKbNufft &lt;https://torchkbnufft.readthedocs.io/en/stable/index.html&gt;`_ package.</span>

<span class="sd">    **Dimensionality**: One consideration when using this layer is the dimensionality of your image and your visibility samples. If your image has multiple channels (``nchan &gt; 1``), there is the possibility that the :math:`u,v` sample locations corresponding to each channel may be different. In ALMA/VLA applications, this can arise when continuum observations are taken over significant bandwidth, since the spatial frequency sampled by any pair of antennas is wavelength-dependent</span>

<span class="sd">    .. math::</span>

<span class="sd">        u = \frac{D}{\lambda},</span>

<span class="sd">    where :math:`D` is the projected baseline (measured in, say, meters) and :math:`\lambda` is the observing wavelength. In this application, the image-plane model could be the same for each channel, or it may vary with channel (necessary if the spectral slope of the source is significant).</span>

<span class="sd">    On the other hand, with spectral line observations it will usually be the case that the total bandwidth of the observations is small enough such that the :math:`u,v` sample locations could be considered as the same for each channel. In spectral line applications, the image-plane model usually varies substantially with each channel.</span>

<span class="sd">    This layer will determine whether the spatial frequencies are treated as constant based upon the dimensionality of the ``uu`` and ``vv`` input arguments.</span>

<span class="sd">    * If ``uu`` and ``vv`` have a shape of (``nvis``), then it will be assumed that the spatial frequencies can be treated as constant with channel (and will invoke parallelization across the image cube ``nchan`` dimension using the &#39;coil&#39; dimension of the TorchKbNufft package).</span>
<span class="sd">    * If the ``uu`` and ``vv`` have a shape of (``nchan, nvis``), then it will be assumed that the spatial frequencies are different for each channel, and the spatial frequencies provided for each channel will be used (and will invoke parallelization across the image cube ``nchan`` dimension using the &#39;batch&#39; dimension of the TorchKbNufft package).</span>

<span class="sd">    Note that there is no straightforward, computationally efficient way to proceed if there are a different number of spatial frequencies for each channel. The best approach is likely to construct ``uu`` and ``vv`` arrays that have a shape of (``nchan, nvis``), such that all channels are padded with bogus :math:`u,v` points to have the same length ``nvis``, and you create a boolean mask to keep track of which points are valid. Then, when this routine returns data points of shape (``nchan, nvis``), you can use that boolean mask to select only the valid :math:`u,v` points points.</span>

<span class="sd">    **Interpolation mode**: You may choose the type of interpolation mode that KbNufft uses under the hood by changing the boolean value of ``sparse_matrices``. For repeated evaluations of this layer (as might exist within an optimization loop), ``sparse_matrices=True`` is likely to be the more accurate and faster choice. If ``sparse_matrices=False``, this routine will use the default table-based interpolation of TorchKbNufft. Note that as of TorchKbNuFFT version 1.4.0, sparse matrices are not yet available when parallelizing using the &#39;batch&#39; dimension --- this will result in a warning.</span>

<span class="sd">    Args:</span>
<span class="sd">        cell_size (float): the width of an image-plane pixel [arcseconds]</span>
<span class="sd">        npix (int): the number of pixels per image side</span>
<span class="sd">        coords (GridCoords): an object already instantiated from the GridCoords class. If providing this, cannot provide ``cell_size`` or ``npix``.</span>
<span class="sd">        nchan (int): the number of channels in the :class:`mpol.images.ImageCube`. Default = 1.</span>
<span class="sd">        uu (np.array): a length ``nvis`` array (not including Hermitian pairs) of the u (East-West) spatial frequency coordinate [klambda]</span>
<span class="sd">        vv (np.array): a length ``nvis`` array (not including Hermitian pairs) of the v (North-South) spatial frequency coordinate [klambda]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nchan</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">uu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sparse_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span> <span class="o">=</span> <span class="n">nchan</span>

        <span class="c1"># initialize the non-uniform FFT object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nufft_ob</span> <span class="o">=</span> <span class="n">torchkbnufft</span><span class="o">.</span><span class="n">KbNufft</span><span class="p">(</span>
            <span class="n">im_size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">uu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">vv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;k_traj&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemble_ktraj</span><span class="p">(</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;uu and vv are required arguments.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sparse_matrices</span> <span class="o">=</span> <span class="n">sparse_matrices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_matrices</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same_uv</span><span class="p">:</span>
                <span class="c1"># precompute the sparse interpolation matrices</span>
                <span class="n">real_interp_mat</span><span class="p">,</span> <span class="n">imag_interp_mat</span> <span class="o">=</span> <span class="n">torchkbnufft</span><span class="o">.</span><span class="n">calc_tensor_spmatrix</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k_traj</span><span class="p">,</span> <span class="n">im_size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;real_interp_mat&quot;</span><span class="p">,</span> <span class="n">real_interp_mat</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;imag_interp_mat&quot;</span><span class="p">,</span> <span class="n">imag_interp_mat</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">warnings</span>

                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Provided uu and vv arrays are multi-dimensional, suggesting an intent to parallelize using the &#39;batch&#39; dimension. This feature is not yet available in TorchKbNuFFT v1.4.0 with sparse matrix interpolation (sparse_matrices=True), therefore we are proceeding with table interpolation (sparse_matrices=False).&quot;</span><span class="p">,</span>
                    <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_mats</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse_matrices</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_image_properties</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">cell_size</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">uu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sparse_matrices</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NuFFT</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">GridCoords</span><span class="p">(</span><span class="n">cell_size</span><span class="p">,</span> <span class="n">npix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">nchan</span><span class="p">,</span> <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">sparse_matrices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_klambda_to_radpix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">klambda</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a spatial frequency in units of klambda to &#39;radians/sky pixel,&#39; using the pixel cell_size provided by ``self.coords.dl``.</span>

<span class="sd">        These concepts can be a little confusing because there are two angular measures at play.</span>

<span class="sd">        1. The first is the normal angular sky coordinate, normally measured in arcseconds for typical sources observed by ALMA or the VLA. Arcseconds, being an angular coordinate, can equivalently be expressed in units of radians. To avoid confusion, we will call this angular measurement &#39;sky radians.&#39; Alternatively, for a given image grid, this same sky coordinate could be expressed in units of sky pixels.</span>
<span class="sd">        2. The second is the spatial frequency of some image-plane function, :math:`I_\nu(l,m)`, which we could quote in units of &#39;cycles per arcsecond&#39; or &#39;cycles per sky pixel,&#39; for example. With a radio interferometer, spatial frequencies are typically quoted in units of the observing wavelength, i.e., lambda or kilo-lambda. If the field of view of the image is small, thanks to the small-angle approximation, units of lambda are directly equivalent to &#39;cycles per sky radian.&#39; The second angular measure comes about when converting the spatial frequency from a linear measure of frequency &#39;cycles per sky radian&#39; to an angular measure of frequency &#39;radians per sky radian&#39; or &#39;radians per sky pixel.&#39;</span>

<span class="sd">        The TorchKbNufft package expects k-trajectory vectors in units of &#39;radians per sky pixel.&#39; This routine helps convert spatial frequencies from their default unit (kilolambda) into &#39;radians per sky pixel&#39; using the pixel cell_size as provided by ``self.coords.dl``.</span>

<span class="sd">        Args:</span>
<span class="sd">            klambda (float): spatial frequency in units of kilolambda</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: spatial frequency measured in units of radian per sky pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># convert from kilolambda to cycles per sky radian</span>
        <span class="n">u_lam</span> <span class="o">=</span> <span class="n">klambda</span> <span class="o">*</span> <span class="mf">1e3</span>  <span class="c1"># [lambda, or cycles/radian]</span>

        <span class="c1"># convert from &#39;cycles per sky radian&#39; to &#39;radians per sky radian&#39;</span>
        <span class="n">u_rad_per_rad</span> <span class="o">=</span> <span class="n">u_lam</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># [radians / sky radian]</span>

        <span class="c1"># size of pixel in radians</span>
        <span class="c1"># self.coords.dl  # [sky radians/pixel]</span>

        <span class="c1"># convert from &#39;radians per sky radian&#39; to &#39;radians per sky pixel&#39;</span>
        <span class="n">u_rad_per_pix</span> <span class="o">=</span> <span class="n">u_rad_per_rad</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">dl</span>  <span class="c1"># [radians / pixel]</span>

        <span class="k">return</span> <span class="n">u_rad_per_pix</span>

    <span class="k">def</span> <span class="nf">_assemble_ktraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This routine converts a series of :math:`u, v` coordinates into a k-trajectory vector for the torchkbnufft routines. The dimensionality of the k-trajectory vector will influence how TorchKbNufft will perform the operations.</span>

<span class="sd">        * If ``uu`` and ``vv`` have a 1D shape of (``nvis``), then it will be assumed that the spatial frequencies can be treated as constant with channel. This will result in a ``k_traj`` vector that has shape (``2, nvis``), such that parallelization will be across the image cube ``nchan`` dimension using the &#39;coil&#39; dimension of the TorchKbNufft package.</span>
<span class="sd">        * If the ``uu`` and ``vv`` have a 2D shape of (``nchan, nvis``), then it will be assumed that the spatial frequencies are different for each channel, and the spatial frequencies provided for each channel will be used. This will result in a ``k_traj`` vector that has shape (``nchan, 2, nvis``), such that parallelization will be across the image cube ``nchan`` dimension using the &#39;batch&#39; dimension of the TorchKbNufft package.</span>

<span class="sd">        Args:</span>
<span class="sd">            uu (1D or 2D numpy array): u (East-West) spatial frequency coordinate [klambda]</span>
<span class="sd">            vv (1D or 2D numpy array): v (North-South) spatial frequency coordinate [klambda]</span>

<span class="sd">        Returns:</span>
<span class="sd">            k_traj (torch tensor): a k-trajectory vector with shape</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">uu_radpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_klambda_to_radpix</span><span class="p">(</span><span class="n">uu</span><span class="p">)</span>
        <span class="n">vv_radpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_klambda_to_radpix</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>

        <span class="c1"># if uu and vv are 1D dimension, then we can assume that we will parallelize across the coil dimension.</span>
        <span class="c1"># otherwise, we assume that we will parallelize across the batch dimension.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">same_uv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uu</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same_uv</span><span class="p">:</span>
            <span class="c1"># k-trajectory needs to be packed the way the image is packed (y,x), so</span>
            <span class="c1"># the trajectory needs to be packed (v, u)</span>
            <span class="c1"># if TorchKbNufft receives a k-traj tensor of shape (2, nvis), it will parallelize across the coil dimension, assuming</span>
            <span class="c1"># that the k-traj is the same for all coils/channels.</span>
            <span class="c1"># interim convert to numpy array because of torch warning about speed</span>
            <span class="n">k_traj</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vv_radpix</span><span class="p">,</span> <span class="n">uu_radpix</span><span class="p">]))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># in this case, we are given two tensors of shape (nchan, nvis)</span>
            <span class="c1"># first, augment each tensor individually to create a (nbatch, 1, nvis) tensor</span>
            <span class="c1"># then, concatenate the tensors along the axis=1 dimension.</span>

            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">uu_radpix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span>
            <span class="p">),</span> <span class="s2">&quot;nchan of uu (</span><span class="si">{:}</span><span class="s2">) is more than one but different than that used to initialize the NuFFT layer (</span><span class="si">{:}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">uu_radpix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">vv_radpix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span>
            <span class="p">),</span> <span class="s2">&quot;nchan of vv (</span><span class="si">{:}</span><span class="s2">) is more than one but different than that used to initialize the NuFFT layer (</span><span class="si">{:}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">vv_radpix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span>
            <span class="p">)</span>

            <span class="n">uu_radpix_aug</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">uu_radpix</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">vv_radpix_aug</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">vv_radpix</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># interim convert to numpy array because of torch warning about speed</span>
            <span class="n">k_traj</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">vv_radpix_aug</span><span class="p">,</span> <span class="n">uu_radpix_aug</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># if TorchKbNufft receives a k-traj tensor of shape (nbatch, 2, nvis), it will parallelize across the batch dimension</span>

        <span class="k">return</span> <span class="n">k_traj</span>

<div class="viewcode-block" id="NuFFT.forward"><a class="viewcode-back" href="../../api.html#mpol.fourier.NuFFT.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the FFT of the image cube for each channel and interpolate to the ``uu`` and ``vv`` points set at layer initialization. This call should automatically take the best parallelization option as indicated by the shape of the ``uu`` and ``vv`` points.</span>

<span class="sd">        Args:</span>
<span class="sd">            cube (torch.double tensor): of shape ``(nchan, npix, npix)``). The cube should be a &quot;prepacked&quot; image cube, for example, from :meth:`mpol.images.ImageCube.forward`</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.complex tensor: of shape ``(nchan, nvis)``, Fourier samples evaluated corresponding to the ``uu``, ``vv`` points set at initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure that the nchan assumptions for the ImageCube and the NuFFT setup are the same</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span>
        <span class="p">),</span> <span class="s2">&quot;nchan of ImageCube (</span><span class="si">{:}</span><span class="s2">) is different than that used to initialize NuFFT layer (</span><span class="si">{:}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchan</span>
        <span class="p">)</span>

        <span class="c1"># &quot;unpack&quot; the cube, but leave it flipped</span>
        <span class="c1"># NuFFT routine expects a &quot;normal&quot; cube, not an fftshifted one</span>
        <span class="n">shifted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># convert the cube to a complex type, since this is required by TorchKbNufft</span>
        <span class="n">complexed</span> <span class="o">=</span> <span class="n">shifted</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

        <span class="c1"># Consider how the similarity of the spatial frequency samples should be treated. We already took care of this on the k_traj side, since we set the shapes. But this also needs to be taken care of on the image side.</span>
        <span class="c1">#   * If we plan to parallelize using the batch dimension, then we need an image with shape (nchan, 1, npix, npix).</span>
        <span class="c1">#   * If we plan to parallelize with the coil dimension, then we need an image with shape (1, nchan, npix, npix).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same_uv</span><span class="p">:</span>
            <span class="c1"># expand the cube to include a batch dimension</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">complexed</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># now [1, nchan, npix, npix] shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">complexed</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># now [nchan, 1, npix, npix] shape</span>

        <span class="c1"># torchkbnufft uses a [nbatch, ncoil, npix, npix] scheme</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_matrices</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">cell_size</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nufft_ob</span><span class="p">(</span>
                <span class="n">expanded</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_traj</span><span class="p">,</span>
                <span class="n">interp_mats</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_interp_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_interp_mat</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">cell_size</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nufft_ob</span><span class="p">(</span><span class="n">expanded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_traj</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same_uv</span><span class="p">:</span>
            <span class="c1"># nchan took on the ncoil position, so remove the nbatch dimension</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># nchan took on the nbatch position, so remove the ncoil dimension</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div></div>


<div class="viewcode-block" id="make_fake_data"><a class="viewcode-back" href="../../api.html#mpol.fourier.make_fake_data">[docs]</a><span class="k">def</span> <span class="nf">make_fake_data</span><span class="p">(</span><span class="n">imageCube</span><span class="p">,</span> <span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a fake dataset from a supplied :class:`mpol.images.ImageCube`. See :ref:`mock-dataset-label` for more details on how to prepare a generic image for use in an :class:`~mpol.images.ImageCube`.</span>

<span class="sd">    The provided visibilities can be 1d for a single continuum channel, or 2d for image cube. If 1d, visibilities will be converted to 2d arrays of shape ``(1, nvis)``.</span>

<span class="sd">    Args:</span>
<span class="sd">        imageCube (:class:`~mpol.images.ImageCube`): the image layer to put into a fake dataset</span>
<span class="sd">        uu (numpy array): array of u spatial frequency coordinates, not including Hermitian pairs. Units of [:math:`\mathrm{k}\lambda`]</span>
<span class="sd">        vv (numpy array): array of v spatial frequency coordinates, not including Hermitian pairs. Units of [:math:`\mathrm{k}\lambda`]</span>
<span class="sd">        weight (2d numpy array): length array of thermal weights :math:`w_i = 1/\sigma_i^2`. Units of [:math:`1/\mathrm{Jy}^2`]</span>

<span class="sd">    Returns:</span>
<span class="sd">        (2-tuple): a two tuple of the fake data. The first array is the mock dataset including noise, the second array is the mock dataset without added noise.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># instantiate a NuFFT object based on the ImageCube</span>
    <span class="c1"># OK if uu shape (nvis,)</span>
    <span class="n">nufft</span> <span class="o">=</span> <span class="n">NuFFT</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">imageCube</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="n">imageCube</span><span class="o">.</span><span class="n">nchan</span><span class="p">,</span> <span class="n">uu</span><span class="o">=</span><span class="n">uu</span><span class="p">,</span> <span class="n">vv</span><span class="o">=</span><span class="n">vv</span><span class="p">)</span>

    <span class="c1"># make into a multi-channel dataset, even if only a single-channel provided</span>
    <span class="k">if</span> <span class="n">uu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">uu</span><span class="p">)</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

    <span class="c1"># carry it forward to the visibilities, which will be (nchan, nvis)</span>
    <span class="n">vis_noiseless</span> <span class="o">=</span> <span class="n">nufft</span><span class="p">(</span><span class="n">imageCube</span><span class="p">())</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># generate complex noise</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
        <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">uu</span><span class="o">.</span><span class="n">shape</span>
    <span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">uu</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># add to data</span>
    <span class="n">vis_noise</span> <span class="o">=</span> <span class="n">vis_noiseless</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="k">return</span> <span class="n">vis_noise</span><span class="p">,</span> <span class="n">vis_noiseless</span></div>


<div class="viewcode-block" id="get_vis_residuals"><a class="viewcode-back" href="../../api.html#mpol.fourier.get_vis_residuals">[docs]</a><span class="k">def</span> <span class="nf">get_vis_residuals</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">u_true</span><span class="p">,</span> <span class="n">v_true</span><span class="p">,</span> <span class="n">V_true</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use `mpol.fourier.NuFFT` to get residuals between gridded `model` and loose </span>
<span class="sd">    (ungridded) data visiblities at data (u, v) coordinates</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `torch.nn.Module` object</span>
<span class="sd">        Instance of the `mpol.precomposed.SimpleNet` class. Contains model </span>
<span class="sd">        visibilities.</span>
<span class="sd">    u_true, v_true : array, unit=[k\lambda]</span>
<span class="sd">        Data u- and v-coordinates</span>
<span class="sd">    V_true : array, unit=[Jy]</span>
<span class="sd">        Data visibility amplitudes </span>
<span class="sd">    channel : int, default=0</span>
<span class="sd">        Channel (of `model`) to use to calculate residual visibilities</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vis_resid : array of complex</span>
<span class="sd">        Model loose residual visibility amplitudes of the form </span>
<span class="sd">        Re(V) + 1j * Im(V)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nufft</span> <span class="o">=</span> <span class="n">NuFFT</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">nchan</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">nchan</span><span class="p">,</span> <span class="n">uu</span><span class="o">=</span><span class="n">u_true</span><span class="p">,</span> <span class="n">vv</span><span class="o">=</span><span class="n">v_true</span><span class="p">)</span>

    <span class="n">vis_model</span> <span class="o">=</span> <span class="n">nufft</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">icube</span><span class="p">())</span>
    <span class="c1"># convert to numpy, select channel</span>
    <span class="n">vis_model</span> <span class="o">=</span> <span class="n">vis_model</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="n">channel</span><span class="p">]</span>

    <span class="n">vis_resid</span> <span class="o">=</span> <span class="n">V_true</span> <span class="o">-</span> <span class="n">vis_model</span>

    <span class="k">return</span> <span class="n">vis_resid</span></div>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Ian Czekala<br/>
  
      &copy; Copyright 2019-22, Ian Czekala.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>

<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>API &#8212; MPoL 0.1.13 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="https://buttons.github.io/buttons.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Introduction to PyTorch: Tensors and Gradient Descent" href="ci-tutorials/PyTorch.html" />
    <link rel="prev" title="Developer Documentation" href="developer-documentation.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">MPoL 0.1.13 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  User Guide
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="rml_intro.html">
   Introduction to Regularized Maximum Likelihood Imaging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="installation.html">
   MPoL Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="units-and-conventions.html">
   Units and Conventions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="developer-documentation.html">
   Developer Documentation
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   API
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tutorials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/PyTorch.html">
   Introduction to PyTorch: Tensors and Gradient Descent
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/gridder.html">
   Gridding and diagnostic images
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/optimization.html">
   Intro to RML with MPoL
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/loose-visibilities.html">
   Likelihood functions and model visibilities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/crossvalidation.html">
   Cross validation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/gpu_setup.html">
   GPU Acceleration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/initializedirtyimage.html">
   Initializing with the Dirty Image
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="large-tutorials/HD143006_part_1.html">
   HD143006 Tutorial Part 1
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="large-tutorials/HD143006_part_2.html">
   HD143006 Tutorial Part 2
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ci-tutorials/fakedata.html">
   Making a Mock Dataset
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="changelog.html">
   Changelog
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/MPoL-dev/MPoL"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/api.rst.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.utils">
   Utilities
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.coordinates">
   Coordinates
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.geometry">
   Geometry
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.gridding">
   Gridding
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.datasets">
   Datasets
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.images">
   Images
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.fourier">
   Fourier
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#precomposed-modules">
   Precomposed Modules
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.losses">
   Losses
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.training">
   Training and testing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.crossval">
   Cross-validation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.plot">
   Plotting
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>API</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.utils">
   Utilities
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.coordinates">
   Coordinates
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.geometry">
   Geometry
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.gridding">
   Gridding
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.datasets">
   Datasets
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.images">
   Images
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.fourier">
   Fourier
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#precomposed-modules">
   Precomposed Modules
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.losses">
   Losses
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.training">
   Training and testing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.crossval">
   Cross-validation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-mpol.plot">
   Plotting
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="api">
<span id="api-reference-label"></span><h1>API<a class="headerlink" href="#api" title="Permalink to this headline">#</a></h1>
<p>This page documents all of the available components of the MPoL package. If you do not see something that you think should be documented, please raise an <a class="reference external" href="https://github.com/iancze/MPoL/issues">issue</a>.</p>
<section id="module-mpol.utils">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-mpol.utils" title="Permalink to this headline">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.torch2npy">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">torch2npy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#torch2npy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.torch2npy" title="Permalink to this definition">#</a></dt>
<dd><p>Make a copy of a PyTorch tensor on the CPU in numpy format, e.g. for plotting</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.ground_cube_to_packed_cube">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">ground_cube_to_packed_cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#ground_cube_to_packed_cube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.ground_cube_to_packed_cube" title="Permalink to this definition">#</a></dt>
<dd><p>Converts a Ground Cube to a Packed Visibility Cube for visibility-plane work. See Units and Conventions for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ground_cube</strong> – a previously initialized Ground Cube object (cube (3D torch tensor of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>))</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3D image cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>; The resulting array after applying <code class="docutils literal notranslate"><span class="pre">torch.fft.fftshift</span></code> to the input arg; i.e Returns a Packed Visibility Cube.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.packed_cube_to_ground_cube">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">packed_cube_to_ground_cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packed_cube</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">torch.Tensor</span></span></span><a class="reference internal" href="_modules/mpol/utils.html#packed_cube_to_ground_cube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.packed_cube_to_ground_cube" title="Permalink to this definition">#</a></dt>
<dd><p>Converts a Packed Visibility Cube to a Ground Cube for visibility-plane work. See Units and Conventions for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>packed_cube</strong> – a previously initialized Packed Cube object (cube (3D torch tensor of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>))</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3D image cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>; The resulting array after applying <code class="docutils literal notranslate"><span class="pre">torch.fft.fftshift</span></code> to the input arg; i.e Returns a Ground Cube.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.sky_cube_to_packed_cube">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">sky_cube_to_packed_cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sky_cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#sky_cube_to_packed_cube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.sky_cube_to_packed_cube" title="Permalink to this definition">#</a></dt>
<dd><p>Converts a Sky Cube to a Packed Image Cube for image-plane work. See Units and Conventions for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sky_cube</strong> – a previously initialized Sky Cube object with RA increasing to the <em>left</em> (cube (3D torch tensor of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>))</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3D image cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>; The resulting array after applying <code class="docutils literal notranslate"><span class="pre">torch.fft.fftshift</span></code> to the <code class="docutils literal notranslate"><span class="pre">torch.flip()</span></code> of the RA axis; i.e Returns a Packed Image Cube.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.packed_cube_to_sky_cube">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">packed_cube_to_sky_cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packed_cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#packed_cube_to_sky_cube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.packed_cube_to_sky_cube" title="Permalink to this definition">#</a></dt>
<dd><p>Converts a Packed Image Cube to a Sky Cube for image-plane work. See Units and Conventions for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>packed_cube</strong> – a previously initialized Packed Image Cube object (cube (3D torch tensor of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>))</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3D image cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>; The resulting array after applying <code class="docutils literal notranslate"><span class="pre">torch.fft.fftshift</span></code> to the <code class="docutils literal notranslate"><span class="pre">torch.flip()</span></code> of the RA axis; i.e Returns a Sky Cube.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.get_Jy_arcsec2">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">get_Jy_arcsec2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">230000000000.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#get_Jy_arcsec2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.get_Jy_arcsec2" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate specific intensity from the brightness temperature, using the Rayleigh-Jeans definition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T_b</strong> – brightness temperature in [<span class="math notranslate nohighlight">\(K\)</span>]</p></li>
<li><p><strong>nu</strong> – frequency (in Hz)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>specific intensity (in [<span class="math notranslate nohighlight">\(\mathrm{Jy}\, \mathrm{arcsec}^2]\)</span>)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.log_stretch">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">log_stretch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#log_stretch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.log_stretch" title="Permalink to this definition">#</a></dt>
<dd><p>Apply a log stretch to the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>PyTorch tensor</em>) – input tensor <span class="math notranslate nohighlight">\(x\)</span></p>
</dd>
</dl>
<p>Returns: <span class="math notranslate nohighlight">\(\ln(1 + |x|)\)</span></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.loglinspace">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">loglinspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_log</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_linear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#loglinspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.loglinspace" title="Permalink to this definition">#</a></dt>
<dd><p>Return a logspaced array of bin edges, with the first <code class="docutils literal notranslate"><span class="pre">M_linear</span></code> cells being equal width. There is a one-cell overlap between the linear and logarithmic stretches of the array, since the last linear cell is also the first logarithmic cell, which means the total number of cells is <code class="docutils literal notranslate"><span class="pre">M_linear</span> <span class="pre">+</span> <span class="pre">N_log</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>float</em>) – starting cell left edge</p></li>
<li><p><strong>end</strong> (<em>float</em>) – ending cell right edge</p></li>
<li><p><strong>N_log</strong> (<em>int</em>) – number of logarithmically spaced bins</p></li>
<li><p><strong>M_linear</strong> (<em>int</em>) – number of linearly (equally) spaced bins</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.fftspace">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">fftspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#fftspace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.fftspace" title="Permalink to this definition">#</a></dt>
<dd><p>Delivers a (nearly) symmetric coordinate array that spans <span class="math notranslate nohighlight">\(N\)</span> elements (where <span class="math notranslate nohighlight">\(N\)</span> is even) from <cite>-width</cite> to <cite>+width</cite>, but ensures that the middle point lands on <span class="math notranslate nohighlight">\(0\)</span>. The array indices go from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(N -1.\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (<em>float</em>) – the width of the array</p></li>
<li><p><strong>N</strong> (<em>int</em>) – the number of elements in the array</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the fftspace array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.float64 1D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.check_baselines">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">check_baselines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_feasible_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_feasible_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#check_baselines"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.check_baselines" title="Permalink to this definition">#</a></dt>
<dd><p>Check if baseline lengths are sensible for expected code unit of
[klambda], or if instead they’re being supplied in [lambda].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>q</strong> (array, unit = <span class="math notranslate nohighlight">\(k\lambda\)</span>) – Baseline distribution (all values must be non-negative).</p>
</dd>
</dl>
<dl>
<dt>min_feasible_q<span class="classifier">float, unit = <span class="math notranslate nohighlight">\(k\lambda\)</span>, default=1e0</span></dt><dd><p>Minimum baseline in code units expected for a dataset. The default
value of 1e0 is a conservative value for ALMA, assuming a minimum
antenna separation of ~12 m and maximum observing wavelength of 3.6 mm.</p>
</dd>
<dt>max_feasible_q<span class="classifier">float, unit = <span class="math notranslate nohighlight">\(k\lambda\)</span>, default=1e5</span></dt><dd><p>Maximum baseline in code units expected for a dataset. The default
value of 1e5 is a conservative value for ALMA, assuming a maximum
antenna separation of ~16 km and minimum observing wavelength of 0.3 mm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.convert_baselines">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">convert_baselines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">baselines</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#convert_baselines"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.convert_baselines" title="Permalink to this definition">#</a></dt>
<dd><p>Convert baselines in meters to kilolambda.
:param baselines: baselines in [m].
:type baselines: float or np.array
:param freq: frequencies in [Hz].
:type freq: float or np.array
:param wle: wavelengths in [m].
:type wle: float or np.array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>baselines in [klambda]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(1D array nvis)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">baselines</span></code>, <code class="docutils literal notranslate"><span class="pre">freq</span></code> or <code class="docutils literal notranslate"><span class="pre">wle</span></code> are numpy arrays, their shapes must be broadcast-able.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.broadcast_and_convert_baselines">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">broadcast_and_convert_baselines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chan_freq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#broadcast_and_convert_baselines"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.broadcast_and_convert_baselines" title="Permalink to this definition">#</a></dt>
<dd><p>Convert baselines to kilolambda and broadcast to match shape of channel frequencies.
:param u: baseline [m]
:type u: 1D array nvis
:param v: baseline [m]
:type v: 1D array nvis
:param chan_freq: frequencies [Hz]
:type chan_freq: 1D array nchan</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(u, v) each of which are (nchan, nvis) arrays of baselines in [klambda]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.get_max_spatial_freq">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">get_max_spatial_freq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#get_max_spatial_freq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.get_max_spatial_freq" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the maximum spatial frequency that the image can represent and still satisfy the Nyquist Sampling theorem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the pixel size in arcseconds</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels in the image</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the maximum spatial frequency contained in the image (in kilolambda)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>max_freq</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.get_maximum_cell_size">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">get_maximum_cell_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uu_vv_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#get_maximum_cell_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.get_maximum_cell_size" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the maximum possible cell_size that will still Nyquist sample the uu or vv point. Note: not q point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>uu_vv_point</strong> (<em>float</em>) – a single spatial frequency. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>].</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>cell_size (in arcsec)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.get_optimal_image_properties">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">get_optimal_image_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#get_optimal_image_properties"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.get_optimal_image_properties" title="Permalink to this definition">#</a></dt>
<dd><p>For an image of desired width, determine the maximum pixel size that
ensures Nyquist sampling of the provided baseline (or baseline
distribution, out to a chosen percentile), and the number of pixels
(given this pixel size) to obtain the desired image width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_width</strong> (<em>float</em><em>, </em><em>unit = arcsec</em>) – Desired width of the image (i.e., image will be a
image_width <span class="math notranslate nohighlight">\(\times\)</span> image_width square).</p></li>
<li><p><strong>q</strong> (float or array, unit = <span class="math notranslate nohighlight">\(k\lambda\)</span>) – Baseline distribution (all values must be non-negative). If a single
value, ‘percentile’ has no effect.</p></li>
<li><p><strong>percentile</strong> (<em>int</em><em>, </em><em>default = 100</em>) – Percentile of the baseline distribution (between 0 - 100) out to which
the desired image will Nyquist sample.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float, unit = arcsec</em>) – Image pixel size required to Nyquist sample.</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – Number of pixels of cell_size to equal (or slightly exceed) the image
width (npix will be rounded up and enforced as even).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To obtain the image properties for a single baseline distance, pass ‘q’ as
a float. In this case, ‘percentile’ has no effect.</p>
<p>No assumption or correction is made concerning whether the baseline
(distribution) is projected or deprojected.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.sky_gaussian_radians">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">sky_gaussian_radians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#sky_gaussian_radians"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.sky_gaussian_radians" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates a 2D Gaussian on the sky plane with inputs in radians. The Gaussian is centered at <code class="docutils literal notranslate"><span class="pre">delta_l,</span> <span class="pre">delta_m</span></code>, has widths of <code class="docutils literal notranslate"><span class="pre">sigma_l,</span> <span class="pre">sigma_m</span></code>, and is rotated <code class="docutils literal notranslate"><span class="pre">Omega</span></code> degrees East of North.</p>
<p>To evaluate the Gaussian, internally first we translate to center</p>
<div class="math notranslate nohighlight">
\[\begin{split}l' = l - \delta_l\\
m' = m - \delta_m\end{split}\]</div>
<p>then rotate coordinates</p>
<div class="math notranslate nohighlight">
\[\begin{split}l'' = l' \cos \phi - m' \sin \phi \\
m'' = l' \sin \phi + m' \cos \phi\end{split}\]</div>
<p>and then evaluate the Gaussian</p>
<div class="math notranslate nohighlight">
\[f_\mathrm{g}(l,m) = a \exp \left ( - \frac{1}{2} \left [ \left (\frac{l''}{\sigma_l} \right)^2 + \left( \frac{m''}{\sigma_m} \right )^2 \right ] \right )\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> – units of [radians]</p></li>
<li><p><strong>m</strong> – units of [radians]</p></li>
<li><p><strong>a</strong> – amplitude prefactor</p></li>
<li><p><strong>delta_l</strong> – offset [radians]</p></li>
<li><p><strong>delta_m</strong> – offset [radians]</p></li>
<li><p><strong>sigma_l</strong> – width [radians]</p></li>
<li><p><strong>sigma_M</strong> – width [radians]</p></li>
<li><p><strong>Omega</strong> – position angle of ascending node [degrees] east of north.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2D Gaussian evaluated at input args with peak amplitude <span class="math notranslate nohighlight">\(a\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.sky_gaussian_arcsec">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">sky_gaussian_arcsec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#sky_gaussian_arcsec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.sky_gaussian_arcsec" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates a Gaussian on the sky plane using inputs in arcsec. This is a convenience wrapper to <a class="reference internal" href="#mpol.utils.sky_gaussian_radians" title="mpol.utils.sky_gaussian_radians"><code class="xref py py-func docutils literal notranslate"><span class="pre">sky_gaussian_radians()</span></code></a> that automatically converts from arcsec to radians.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – equivalent to l, but in units of [arcsec]</p></li>
<li><p><strong>y</strong> – equivalent to m, but in units of [arcsec]</p></li>
<li><p><strong>a</strong> – amplitude prefactor</p></li>
<li><p><strong>delta_x</strong> – offset [arcsec]</p></li>
<li><p><strong>delta_y</strong> – offset [arcsec]</p></li>
<li><p><strong>sigma_x</strong> – width [arcsec]</p></li>
<li><p><strong>sigma_y</strong> – width [arcsec]</p></li>
<li><p><strong>Omega</strong> – position angle of ascending node [degrees] east of north.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2D Gaussian evaluated at input args with peak amplitude <span class="math notranslate nohighlight">\(a\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.fourier_gaussian_lambda_radians">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">fourier_gaussian_lambda_radians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#fourier_gaussian_lambda_radians"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.fourier_gaussian_lambda_radians" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the Fourier plane Gaussian <span class="math notranslate nohighlight">\(F_\mathrm{g}(u,v)\)</span> corresponding to the Sky plane Gaussian <span class="math notranslate nohighlight">\(f_\mathrm{g}(l,m)\)</span> in <a class="reference internal" href="#mpol.utils.sky_gaussian_radians" title="mpol.utils.sky_gaussian_radians"><code class="xref py py-func docutils literal notranslate"><span class="pre">sky_gaussian_radians()</span></code></a>, using analytical relationships. The Fourier Gaussian is parameterized using the sky plane centroid (<code class="docutils literal notranslate"><span class="pre">delta_l,</span> <span class="pre">delta_m</span></code>), widths (<code class="docutils literal notranslate"><span class="pre">sigma_l,</span> <span class="pre">sigma_m</span></code>) and rotation (<code class="docutils literal notranslate"><span class="pre">Omega</span></code>). Assumes that <code class="docutils literal notranslate"><span class="pre">a</span></code> was in units of <span class="math notranslate nohighlight">\(\mathrm{Jy}/\mathrm{steradian}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – l in units of [lambda]</p></li>
<li><p><strong>v</strong> – m in units of [lambda]</p></li>
<li><p><strong>a</strong> – amplitude prefactor, units of <span class="math notranslate nohighlight">\(\mathrm{Jy}/\mathrm{steradian}\)</span>.</p></li>
<li><p><strong>delta_x</strong> – offset [radians]</p></li>
<li><p><strong>delta_y</strong> – offset [radians]</p></li>
<li><p><strong>sigma_x</strong> – width [radians]</p></li>
<li><p><strong>sigma_y</strong> – width [radians]</p></li>
<li><p><strong>Omega</strong> – position angle of ascending node [degrees] east of north.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2D Gaussian evaluated at input args</p>
</dd>
</dl>
<p>The following is a description of how we derived the analytical relationships. In what follows, all <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(m\)</span> coordinates are assumed to be in units of radians and all <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> coordinates are assumed to be in units of <span class="math notranslate nohighlight">\(\lambda\)</span>.</p>
<p>We start from Fourier dual relationships in Bracewell’s <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2000fta..book.....B/abstract">The Fourier Transform and Its Applications</a></p>
<div class="math notranslate nohighlight">
\[f_0(l, m) \leftrightharpoons F_0(u, v)\]</div>
<p>where the sky-plane and Fourier-plane Gaussians are</p>
<div class="math notranslate nohighlight">
\[f_0(l,m) = a \exp \left ( -\pi [l^2 + m^2] \right)\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[F_0(u,v) = a \exp \left ( -\pi [u^2 + v^2] \right),\]</div>
<p>respectively. The sky-plane Gaussian has a maximum value of <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>We will use the similarity, rotation, and shift theorems to turn <span class="math notranslate nohighlight">\(f_0\)</span> into a form matching <span class="math notranslate nohighlight">\(f_\mathrm{g}\)</span>, which simultaneously turns <span class="math notranslate nohighlight">\(F_0\)</span> into <span class="math notranslate nohighlight">\(F_\mathrm{g}(u,v)\)</span>.</p>
<p>The similarity theorem states that (in 1D)</p>
<div class="math notranslate nohighlight">
\[f(bl) = \frac{1}{|b|}F\left(\frac{u}{b}\right).\]</div>
<p>First, we scale <span class="math notranslate nohighlight">\(f_0\)</span> to include sigmas. Let</p>
<div class="math notranslate nohighlight">
\[f_1(l, m) = a \exp \left(-\frac{1}{2} \left [\left(\frac{l}{\sigma_l}\right)^2 + \left( \frac{m}{\sigma_m} \right)^2 \right] \right).\]</div>
<p>i.e., something we might call a normalized Gaussian function. Phrased in terms of <span class="math notranslate nohighlight">\(f_0\)</span>, <span class="math notranslate nohighlight">\(f_1\)</span> is</p>
<div class="math notranslate nohighlight">
\[f_1(l, m) = f_0\left ( \frac{l}{\sigma_l \sqrt{2 \pi}},\, \frac{m}{\sigma_m \sqrt{2 \pi}}\right).\]</div>
<p>Therefore, according to the similarity theorem, the equivalent <span class="math notranslate nohighlight">\(F_1(u,v)\)</span> is</p>
<div class="math notranslate nohighlight">
\[F_1(u, v) = \sigma_l \sigma_m 2 \pi F_0 \left( \sigma_l \sqrt{2 \pi} u,\, \sigma_m \sqrt{2 \pi} v \right),\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[F_1(u, v) = a \sigma_l \sigma_m 2 \pi \exp \left ( -2 \pi^2 [\sigma_l^2 u^2 + \sigma_m^2 v^2] \right).\]</div>
<p>Next, we rotate the Gaussian to match the sky plane rotation. A rotation <span class="math notranslate nohighlight">\(\Omega\)</span> in the sky plane is carried out in the same direction in the Fourier plane,</p>
<div class="math notranslate nohighlight">
\[\begin{split}u' = u \cos \Omega - v \sin \Omega \\
v' = u \sin \Omega + v \cos \Omega\end{split}\]</div>
<p>such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}f_2(l, m) = f_1(l', m') \\
F_2(u, v) = F_1(u', m')\end{split}\]</div>
<p>Finally, we translate the sky plane Gaussian by amounts <span class="math notranslate nohighlight">\(\delta_l\)</span>, <span class="math notranslate nohighlight">\(\delta_m\)</span>, which corresponds to a phase shift in the Fourier plane Gaussian. The image plane translation is</p>
<div class="math notranslate nohighlight">
\[f_3(l,m) = f_2(l - \delta_l, m - \delta_m)\]</div>
<p>According to the shift theorem, the equivalent <span class="math notranslate nohighlight">\(F_3(u,v)\)</span> is</p>
<div class="math notranslate nohighlight">
\[F_3(u,v) = \exp\left (- 2 i \pi [\delta_l u + \delta_m v] \right) F_2(u,v)\]</div>
<p>We have arrived at the corresponding Fourier Gaussian, <span class="math notranslate nohighlight">\(F_\mathrm{g}(u,v) = F_3(u,v)\)</span>. The simplified equation is</p>
<div class="math notranslate nohighlight">
\[F_\mathrm{g}(u,v) = a \sigma_l \sigma_m 2 \pi \exp \left ( -2 \pi^2 \left [\sigma_l^2 u'^2 + \sigma_m^2 v'^2 \right]  - 2 i \pi \left [\delta_l u + \delta_m v \right] \right).\]</div>
<p>N.B. that we have mixed primed (<span class="math notranslate nohighlight">\(u'\)</span>) and unprimed (<span class="math notranslate nohighlight">\(u\)</span>) coordinates in the same equation for brevity.</p>
<p>Finally, the same Fourier dual relationship holds</p>
<div class="math notranslate nohighlight">
\[f_\mathrm{g}(l,m) \leftrightharpoons F_\mathrm{g}(u,v)\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.utils.fourier_gaussian_klambda_arcsec">
<span class="sig-prename descclassname"><span class="pre">mpol.utils.</span></span><span class="sig-name descname"><span class="pre">fourier_gaussian_klambda_arcsec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/utils.html#fourier_gaussian_klambda_arcsec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.utils.fourier_gaussian_klambda_arcsec" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the Fourier plane Gaussian <span class="math notranslate nohighlight">\(F_\mathrm{g}(u,v)\)</span> corresponding to the Sky plane Gaussian <span class="math notranslate nohighlight">\(f_\mathrm{g}(l,m)\)</span> in <a class="reference internal" href="#mpol.utils.sky_gaussian_arcsec" title="mpol.utils.sky_gaussian_arcsec"><code class="xref py py-func docutils literal notranslate"><span class="pre">sky_gaussian_arcsec()</span></code></a>, using analytical relationships. The Fourier Gaussian is parameterized using the sky plane centroid (<code class="docutils literal notranslate"><span class="pre">delta_l,</span> <span class="pre">delta_m</span></code>), widths (<code class="docutils literal notranslate"><span class="pre">sigma_l,</span> <span class="pre">sigma_m</span></code>) and rotation (<code class="docutils literal notranslate"><span class="pre">Omega</span></code>). Assumes that <code class="docutils literal notranslate"><span class="pre">a</span></code> was in units of <span class="math notranslate nohighlight">\(\mathrm{Jy}/\mathrm{arcsec}^2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – l in units of [klambda]</p></li>
<li><p><strong>v</strong> – m in units of [klambda]</p></li>
<li><p><strong>a</strong> – amplitude prefactor, units of <span class="math notranslate nohighlight">\(\mathrm{Jy}/\mathrm{arcsec}^2\)</span>.</p></li>
<li><p><strong>delta_x</strong> – offset [arcsec]</p></li>
<li><p><strong>delta_y</strong> – offset [arcsec]</p></li>
<li><p><strong>sigma_x</strong> – width [arcsec]</p></li>
<li><p><strong>sigma_y</strong> – width [arcsec]</p></li>
<li><p><strong>Omega</strong> – position angle of ascending node [degrees] east of north.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2D Fourier Gaussian evaluated at input args</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mpol.coordinates">
<span id="coordinates"></span><h2>Coordinates<a class="headerlink" href="#module-mpol.coordinates" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mpol.coordinates.GridCoords">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.coordinates.</span></span><span class="sig-name descname"><span class="pre">GridCoords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/coordinates.html#GridCoords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.coordinates.GridCoords" title="Permalink to this definition">#</a></dt>
<dd><p>The GridCoords object uses desired image dimensions (via the <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> and <code class="docutils literal notranslate"><span class="pre">npix</span></code> arguments) to define a corresponding Fourier plane grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – width of a single square pixel in [arcsec]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – number of pixels in the width of the image</p></li>
</ul>
</dd>
</dl>
<p>The Fourier grid is defined over the domain <span class="math notranslate nohighlight">\([-u,+u]\)</span>, <span class="math notranslate nohighlight">\([-v,+v]\)</span>, even though for real images, technically we could use an RFFT grid from <span class="math notranslate nohighlight">\([0,+u]\)</span> to <span class="math notranslate nohighlight">\([-v,+v]\)</span>. The reason we opt for a full FFT grid in this instance is implementation simplicity.</p>
<p>Images (and their corresponding Fourier transform quantities) are represented as two-dimensional arrays packed as <code class="docutils literal notranslate"><span class="pre">[y,</span> <span class="pre">x]</span></code> and <code class="docutils literal notranslate"><span class="pre">[v,</span> <span class="pre">u]</span></code>.  This means that an image with dimensions <code class="docutils literal notranslate"><span class="pre">(npix,</span> <span class="pre">npix)</span></code> will also have a corresponding FFT Fourier grid with shape <code class="docutils literal notranslate"><span class="pre">(npix,</span> <span class="pre">npix)</span></code>. The native <code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code> representation assumes the Fourier grid (and thus image) are laid out as one might normally expect an image (i.e., no <code class="docutils literal notranslate"><span class="pre">np.fft.fftshift</span></code> has been applied).</p>
<p>After the object is initialized, instance variables can be accessed, for example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myCoords</span> <span class="o">=</span> <span class="n">GridCoords</span><span class="p">(</span><span class="n">cell_size</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myCoords</span><span class="o">.</span><span class="n">img_ext</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dl</strong> – image-plane cell spacing in RA direction (assumed to be positive) [radians]</p></li>
<li><p><strong>dm</strong> – image-plane cell spacing in DEC direction [radians]</p></li>
<li><p><strong>img_ext</strong> – The length-4 list of (left, right, bottom, top) expected by routines like <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.imshow</span></code> in the <code class="docutils literal notranslate"><span class="pre">extent</span></code> parameter assuming <code class="docutils literal notranslate"><span class="pre">origin='lower'</span></code>. Units of [arcsec]</p></li>
<li><p><strong>packed_x_centers_2D</strong> – 2D array of l increasing, with fftshifted applied [arcseconds]. Useful for directly evaluating some function to create a packed cube.</p></li>
<li><p><strong>packed_y_centers_2D</strong> – 2D array of m increasing, with fftshifted applied [arcseconds]. Useful for directly evaluating some function to create a packed cube.</p></li>
<li><p><strong>sky_x_centers_2D</strong> – 2D array of l arranged for evaluating a sky image [arcseconds]. l coordinate increases to the left (as on sky).</p></li>
<li><p><strong>sky_y_centers_2D</strong> – 2D array of m arranged for evaluating a sky image [arcseconds].</p></li>
<li><p><strong>du</strong> – Fourier-plane cell spacing in East-West direction [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>dv</strong> – Fourier-plane cell spacing in North-South direction [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>u_centers</strong> – 1D array of cell centers in East-West direction [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>].</p></li>
<li><p><strong>v_centers</strong> – 1D array of cell centers in North-West direction [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>].</p></li>
<li><p><strong>u_edges</strong> – 1D array of cell edges in East-West direction [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>].</p></li>
<li><p><strong>v_edges</strong> – 1D array of cell edges in North-South direction [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>].</p></li>
<li><p><strong>u_bin_min</strong> – minimum u edge [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>u_bin_max</strong> – maximum u edge [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>v_bin_min</strong> – minimum v edge [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>v_bin_max</strong> – maximum v edge [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>max_grid</strong> – maximum spatial frequency enclosed by Fourier grid [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vis_ext</strong> – length-4 list of (left, right, bottom, top) expected by routines like <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.imshow</span></code> in the <code class="docutils literal notranslate"><span class="pre">extent</span></code> parameter assuming <code class="docutils literal notranslate"><span class="pre">origin='lower'</span></code>. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.coordinates.GridCoords.check_data_fit">
<span class="sig-name descname"><span class="pre">check_data_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy._typing._array_like._SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.dtype</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy._typing._nested_sequence._NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy._typing._array_like._SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.dtype</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy._typing._nested_sequence._NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy._typing._array_like._SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.dtype</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy._typing._nested_sequence._NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy._typing._array_like._SupportsArray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.dtype</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy._typing._nested_sequence._NestedSequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">complex</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bytes</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/mpol/coordinates.html#GridCoords.check_data_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.coordinates.GridCoords.check_data_fit" title="Permalink to this definition">#</a></dt>
<dd><p>Test whether loose data visibilities fit within the Fourier grid defined by cell_size and npix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uu</strong> (<em>np.array</em>) – array of u spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vv</strong> (<em>np.array</em>) – array of v spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if all visibilities fit within the Fourier grid defined by <code class="docutils literal notranslate"><span class="pre">[u_bin_min,</span> <span class="pre">u_bin_max,</span> <span class="pre">v_bin_min,</span> <span class="pre">v_bin_max]</span></code>. Otherwise an <code class="docutils literal notranslate"><span class="pre">AssertionError</span></code> is raised on the first violated boundary.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mpol.geometry">
<span id="geometry"></span><h2>Geometry<a class="headerlink" href="#module-mpol.geometry" title="Permalink to this headline">#</a></h2>
<p>The geometry package provides routines for projecting and de-projecting sky images.</p>
<dl class="py function">
<dt class="sig sig-object py" id="mpol.geometry.flat_to_observer">
<span class="sig-prename descclassname"><span class="pre">mpol.geometry.</span></span><span class="sig-name descname"><span class="pre">flat_to_observer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/geometry.html#flat_to_observer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.geometry.flat_to_observer" title="Permalink to this definition">#</a></dt>
<dd><p>Rotate the frame to convert a point in the flat (x,y,z) frame to observer frame (X,Y,Z).</p>
<p>It is assumed that the +Z axis points <em>towards</em> the observer. It is assumed that the model is flat in the (x,y) frame (like a flat disk), and so the operations involving <code class="docutils literal notranslate"><span class="pre">z</span></code> are neglected. But the model lives in 3D Cartesian space.</p>
<p>In order,</p>
<ol class="arabic simple">
<li><p>rotate about the z axis by an amount omega -&gt; x1, y1, z1</p></li>
<li><p>rotate about the x1 axis by an amount -incl -&gt; x2, y2, z2</p></li>
<li><p>rotate about the z2 axis by an amount Omega -&gt; x3, y3, z3 = X, Y, Z</p></li>
</ol>
<p>Inspired by <a class="reference external" href="https://github.com/exoplanet-dev/exoplanet/blob/main/src/exoplanet/orbits/keplerian.py">exoplanet/keplerian.py</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>torch tensor</em>) – A tensor representing the x coordinate in the plane of the orbit.</p></li>
<li><p><strong>y</strong> (<em>torch tensor</em>) – A tensor representing the y coordinate in the plane of the orbit.</p></li>
<li><p><strong>omega</strong> (<em>torch float tensor</em>) – A tensor representing an argument of periastron [radians] Default 0.0.</p></li>
<li><p><strong>incl</strong> (<em>torch float tensor</em>) – A tensor representing an inclination value [radians]. Default 0.0.</p></li>
<li><p><strong>Omega</strong> (<em>torch float tensor</em>) – A tensor representing the position angle of the ascending node in [radians]. Default 0.0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Two tensors representing <code class="docutils literal notranslate"><span class="pre">(X,</span> <span class="pre">Y)</span></code> in the observer frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.geometry.observer_to_flat">
<span class="sig-prename descclassname"><span class="pre">mpol.geometry.</span></span><span class="sig-name descname"><span class="pre">observer_to_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/geometry.html#observer_to_flat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.geometry.observer_to_flat" title="Permalink to this definition">#</a></dt>
<dd><p>Rotate the from to convert a point in the observer frame (X,Y,Z) to the flat (x,y,z) frame.</p>
<p>It is assumed that the +Z axis points <em>towards</em> the observer. The rotation operations are the inverse of the <a class="reference internal" href="#mpol.geometry.flat_to_observer" title="mpol.geometry.flat_to_observer"><code class="xref py py-func docutils literal notranslate"><span class="pre">flat_to_observer()</span></code></a> operations.</p>
<p>In order,</p>
<ol class="arabic simple">
<li><p>inverse rotation about the Z axis by an amount Omega -&gt; x2, y2, z2</p></li>
<li><p>inverse rotation about the x2 axis by an amount -incl -&gt; x1, y1, z1</p></li>
<li><p>inverse rotation about the z1 axis by an amount omega -&gt; x, y, z</p></li>
</ol>
<p>Inspired by <a class="reference external" href="https://github.com/exoplanet-dev/exoplanet/blob/main/src/exoplanet/orbits/keplerian.py">exoplanet/keplerian.py</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch tensor</em>) – A tensor representing the x coodinate in the plane of the orbit.</p></li>
<li><p><strong>Y</strong> (<em>torch.tensor</em>) – A tensor representing the y coodinate in the plane of the orbit.</p></li>
<li><p><strong>omega</strong> (<em>torch float tensor</em>) – A tensor representing an argument of periastron [radians] Default 0.0.</p></li>
<li><p><strong>incl</strong> (<em>torch float tensor</em>) – A tensor representing an inclination value [radians]. Default 0.0.</p></li>
<li><p><strong>Omega</strong> (<em>torch float tensor</em>) – A tensor representing the position angle of the ascending node in [radians]. Default 0.0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Two tensors representing <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> in the observer frame.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mpol.gridding">
<span id="gridding"></span><h2>Gridding<a class="headerlink" href="#module-mpol.gridding" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">gridding</span></code> module provides two core classes in <a class="reference internal" href="#mpol.gridding.DataAverager" title="mpol.gridding.DataAverager"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.gridding.DataAverager</span></code></a> and <a class="reference internal" href="#mpol.gridding.DirtyImager" title="mpol.gridding.DirtyImager"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.gridding.DirtyImager</span></code></a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="mpol.gridding.verify_no_hermitian_pairs">
<span class="sig-prename descclassname"><span class="pre">mpol.gridding.</span></span><span class="sig-name descname"><span class="pre">verify_no_hermitian_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_vis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/gridding.html#verify_no_hermitian_pairs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.gridding.verify_no_hermitian_pairs" title="Permalink to this definition">#</a></dt>
<dd><p>Check that the dataset does not contain Hermitian pairs. Because the sky brightness <span class="math notranslate nohighlight">\(I_\nu\)</span> is real, the visibility function <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> is Hermitian, meaning that</p>
<div class="math notranslate nohighlight">
\[\mathcal{V}(u, v) = \mathcal{V}^*(-u, -v).\]</div>
<p>Most datasets (e.g., those extracted from CASA) will only record one visibility measurement per baseline and not include the duplicate Hermitian pair (to save storage space). This routine attempts to determine if the dataset contains Hermitian pairs or not by choosing one data point at a time and then searching the dataset to see if its Hermitian pair exists. The routine will declare that a dataset contains Hermitian pairs or not after it has searched <code class="docutils literal notranslate"><span class="pre">test_vis</span></code> number of data points. If 0 Hermitian pairs have been found for all <code class="docutils literal notranslate"><span class="pre">test_vis</span></code> points, then the dataset will be declared to have no Hermitian pairs. If <code class="docutils literal notranslate"><span class="pre">test_vis</span></code> Hermitian pairs were found for <code class="docutils literal notranslate"><span class="pre">test_vis</span></code> points searched, then the dataset will be declared to have Hermitian pairs. If more than 0 but fewer than <code class="docutils literal notranslate"><span class="pre">test_vis</span></code> Hermitian pairs were found for <code class="docutils literal notranslate"><span class="pre">test_vis</span></code> points, an error will be raised.</p>
<p>Gridding objects like <a class="reference internal" href="#mpol.gridding.DirtyImager" title="mpol.gridding.DirtyImager"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.gridding.DirtyImager</span></code></a> will naturally augment an input dataset to include the Hermitian pairs, so that images of <span class="math notranslate nohighlight">\(I_\nu\)</span> produced with the inverse Fourier transform turn out to be real.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uu</strong> (<em>numpy array</em>) – array of u spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vv</strong> (<em>numpy array</em>) – array of v spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>data</strong> (<em>numpy complex</em>) – array of data values</p></li>
<li><p><strong>test_vis</strong> (<em>int</em>) – the number of data points to search for Hermitian ‘matches’</p></li>
<li><p><strong>test_channel</strong> (<em>int</em>) – the index of the channel to perform the check</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if dataset does contain Hermitian pairs, <code class="docutils literal notranslate"><span class="pre">False</span></code> if not.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.gridding.GridderBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.gridding.</span></span><span class="sig-name descname"><span class="pre">GridderBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_re</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_im</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/gridding.html#GridderBase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.gridding.GridderBase" title="Permalink to this definition">#</a></dt>
<dd><p>This class is not designed to be used directly, but rather to be subclassed.</p>
<p>Subclasses will need to implement a <cite>_grid_visibilities(self,…)</cite> method.</p>
<p>The GridderBase object uses desired image dimensions (via the <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> and <code class="docutils literal notranslate"><span class="pre">npix</span></code> arguments) to define a corresponding Fourier plane grid as a <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> object. A pre-computed <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> can be supplied in lieu of <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> and <code class="docutils literal notranslate"><span class="pre">npix</span></code>, but all three arguments should never be supplied at once. For more details on the properties of the grid that is created, see the <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> documentation.</p>
<p>Subclasses will accept “loose” <em>ungridded</em> visibility data and store the arrays to the object as instance attributes. The input visibility data should be the set of visibilities over the full <span class="math notranslate nohighlight">\([-u,u]\)</span> and <span class="math notranslate nohighlight">\([-v,v]\)</span> domain, and should not contain Hermitian pairs (an error will be raised, if they are encountered).  The visibilities can be 1d for a single continuum channel, or 2d for an image cube. If 1d, visibilities will be converted to 2d arrays of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">nvis)</span></code>. Like the <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageCube</span></code></a> class, after construction, GridderBase assumes that you are operating with a multi-channel set of visibilities. These routines will still work with single-channel ‘continuum’ visibilities, they will just have nchan = 1 in the first dimension of most products.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>uu</strong> (<em>numpy array</em>) – (nchan, nvis) array of u spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vv</strong> (<em>numpy array</em>) – (nchan, nvis) array of v spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>weight</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of thermal weights. Units of [<span class="math notranslate nohighlight">\(1/\mathrm{Jy}^2\)</span>]</p></li>
<li><p><strong>data_re</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of the real part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
<li><p><strong>data_im</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of the imaginary part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="mpol.gridding.GridderBase.ground_cube">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ground_cube</span></span><a class="headerlink" href="#mpol.gridding.GridderBase.ground_cube" title="Permalink to this definition">#</a></dt>
<dd><p>The visibility FFT cube fftshifted for plotting with <code class="docutils literal notranslate"><span class="pre">imshow</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the FFT of the image cube, in sky plane format.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(torch.complex tensor, of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.gridding.DataAverager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.gridding.</span></span><span class="sig-name descname"><span class="pre">DataAverager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_re</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_im</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/gridding.html#DataAverager"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.gridding.DataAverager" title="Permalink to this definition">#</a></dt>
<dd><p>The DataAverager object uses desired image dimensions (via the <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> and <code class="docutils literal notranslate"><span class="pre">npix</span></code> arguments) to define a corresponding Fourier plane grid as a <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> object. A pre-computed <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> can be supplied in lieu of <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> and <code class="docutils literal notranslate"><span class="pre">npix</span></code>, but all three arguments should never be supplied at once. For more details on the properties of the grid that is created, see the <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> documentation.</p>
<p>The <a class="reference internal" href="#mpol.gridding.DataAverager" title="mpol.gridding.DataAverager"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataAverager</span></code></a> object accepts “loose” <em>ungridded</em> visibility data and stores the arrays to the object as instance attributes. The input visibility data should be the set of visibilities over the full <span class="math notranslate nohighlight">\([-u,u]\)</span> and <span class="math notranslate nohighlight">\([-v,v]\)</span> domain, and should not contain Hermitian pairs (an error will be raised, if they are encountered). (Note that, unlike <a class="reference internal" href="#mpol.gridding.DirtyImager" title="mpol.gridding.DirtyImager"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirtyImager</span></code></a>, this class <em>will not</em> augment the dataset to include Hermitian pairs. This is by design, since Hermitian pairs should not be used in likelihood calculations).</p>
<p>The input visibilities can be 1d for a single continuum channel, or 2d for image cube. If 1d, visibilities will be converted to 2d arrays of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">nvis)</span></code>. Like the <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageCube</span></code></a> class, after construction, the DataAverager assumes that you are operating with a multi-channel set of visibilities. These routines will still work with single-channel ‘continuum’ visibilities, they will just have nchan = 1 in the first dimension of most products.</p>
<p>Once the DataAverager object is initialized with loose visibilities, you can average them and export them for use in Regularized Maximum Likelihood imaging with the <a class="reference internal" href="#mpol.gridding.DataAverager.to_pytorch_dataset" title="mpol.gridding.DataAverager.to_pytorch_dataset"><code class="xref py py-func docutils literal notranslate"><span class="pre">mpol.gridding.DataAverager.to_pytorch_dataset()</span></code></a> routine.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">averager</span> <span class="o">=</span> <span class="n">gridding</span><span class="o">.</span><span class="n">DataAverager</span><span class="p">(</span>
    <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
    <span class="n">uu</span><span class="o">=</span><span class="n">uu</span><span class="p">,</span>
    <span class="n">vv</span><span class="o">=</span><span class="n">vv</span><span class="p">,</span>
    <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
    <span class="n">data_re</span><span class="o">=</span><span class="n">data_re</span><span class="p">,</span>
    <span class="n">data_im</span><span class="o">=</span><span class="n">data_im</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">dset</span> <span class="o">=</span> <span class="n">averager</span><span class="o">.</span><span class="n">to_pytorch_dataset</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>uu</strong> (<em>numpy array</em>) – (nchan, nvis) array of u spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vv</strong> (<em>numpy array</em>) – (nchan, nvis) array of v spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>weight</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of thermal weights. Units of [<span class="math notranslate nohighlight">\(1/\mathrm{Jy}^2\)</span>]</p></li>
<li><p><strong>data_re</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of the real part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
<li><p><strong>data_im</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of the imaginary part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.gridding.DataAverager.to_pytorch_dataset">
<span class="sig-name descname"><span class="pre">to_pytorch_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check_visibility_scatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_scatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/gridding.html#DataAverager.to_pytorch_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.gridding.DataAverager.to_pytorch_dataset" title="Permalink to this definition">#</a></dt>
<dd><p>Export gridded visibilities to a PyTorch dataset object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>check_visibility_scatter</strong> (<em>bool</em>) – whether the routine should check the standard deviation of visibilities in each within each <span class="math notranslate nohighlight">\(u,v\)</span> cell (<span class="math notranslate nohighlight">\(\mathrm{cell}_{i,j}\)</span>) defined by <code class="docutils literal notranslate"><span class="pre">self.coords</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>. A <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> will be raised if any cell has a scatter larger than <code class="docutils literal notranslate"><span class="pre">max_scatter</span></code>.</p></li>
<li><p><strong>max_scatter</strong> (<em>float</em>) – the maximum allowable standard deviation of visibility values in a given <span class="math notranslate nohighlight">\(u,v\)</span> cell (<span class="math notranslate nohighlight">\(\mathrm{cell}_{i,j}\)</span>) defined by <code class="docutils literal notranslate"><span class="pre">self.coords</span></code>. Defaults to a factor of 120%.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> with gridded visibilities.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.gridding.DirtyImager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.gridding.</span></span><span class="sig-name descname"><span class="pre">DirtyImager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_re</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_im</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/gridding.html#DirtyImager"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.gridding.DirtyImager" title="Permalink to this definition">#</a></dt>
<dd><p>This class is mainly used for producing diagnostic “dirty” images of the visibility data.</p>
<p>The DirtyImager object uses desired image dimensions (via the <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> and <code class="docutils literal notranslate"><span class="pre">npix</span></code> arguments) to define a corresponding Fourier plane grid as a <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> object. A pre-computed <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> can be supplied in lieu of <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> and <code class="docutils literal notranslate"><span class="pre">npix</span></code>, but all three arguments should never be supplied at once. For more details on the properties of the grid that is created, see the <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> documentation.</p>
<p>The <a class="reference internal" href="#mpol.gridding.DirtyImager" title="mpol.gridding.DirtyImager"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirtyImager</span></code></a> object accepts “loose” <em>ungridded</em> visibility data and stores the arrays to the object as instance attributes. The input visibility data should be the normal set of visibilities over the full <span class="math notranslate nohighlight">\([-u,u]\)</span> and <span class="math notranslate nohighlight">\([-v,v]\)</span> domain; internally the DirtyImager will automatically augment the dataset to include the complex conjugates, i.e. the ‘Hermitian pairs.’</p>
<p>The input visibilities can be 1d for a single continuum channel, or 2d for image cube. If 1d, visibilities will be converted to 2d arrays of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">nvis)</span></code>. Like the <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageCube</span></code></a> class, after construction, the DirtyImager assumes that you are operating with a multi-channel set of visibilities. These routines will still work with single-channel ‘continuum’ visibilities, they will just have nchan = 1 in the first dimension of most products.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">imager</span> <span class="o">=</span> <span class="n">gridding</span><span class="o">.</span><span class="n">DirtyImager</span><span class="p">(</span>
    <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
    <span class="n">uu</span><span class="o">=</span><span class="n">uu</span><span class="p">,</span>
    <span class="n">vv</span><span class="o">=</span><span class="n">vv</span><span class="p">,</span>
    <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
    <span class="n">data_re</span><span class="o">=</span><span class="n">data_re</span><span class="p">,</span>
    <span class="n">data_im</span><span class="o">=</span><span class="n">data_im</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">img</span><span class="p">,</span> <span class="n">beam</span> <span class="o">=</span> <span class="n">imager</span><span class="o">.</span><span class="n">get_dirty_image</span><span class="p">(</span><span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;briggs&quot;</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – width of a single square pixel in [arcsec]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – number of pixels in the width of the image</p></li>
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>uu</strong> (<em>numpy array</em>) – (nchan, nvis) array of u spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vv</strong> (<em>numpy array</em>) – (nchan, nvis) array of v spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>weight</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of thermal weights. Units of [<span class="math notranslate nohighlight">\(1/\mathrm{Jy}^2\)</span>]</p></li>
<li><p><strong>data_re</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of the real part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
<li><p><strong>data_im</strong> (<em>2d numpy array</em>) – (nchan, nvis) array of the imaginary part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.gridding.DirtyImager.get_dirty_beam_area">
<span class="sig-name descname"><span class="pre">get_dirty_beam_area</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ntheta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">24</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">single_channel_estimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/gridding.html#DirtyImager.get_dirty_beam_area"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.gridding.DirtyImager.get_dirty_beam_area" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the effective area of the dirty beam for each channel. Assumes that the beam has already been generated by running <a class="reference internal" href="#mpol.gridding.DirtyImager.get_dirty_image" title="mpol.gridding.DirtyImager.get_dirty_image"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_dirty_image()</span></code></a>. This is an approximate calculation involving a simple sum over all pixels out to the first null (zero crossing) of the dirty beam. This quantity is designed to approximate the conversion of image units from <span class="math notranslate nohighlight">\([\mathrm{Jy}\,\mathrm{beam}^{-1}]\)</span> to <span class="math notranslate nohighlight">\([\mathrm{Jy}\,\mathrm{arcsec}^{-2}]\)</span>, even though units of <span class="math notranslate nohighlight">\([\mathrm{Jy}\,\mathrm{dirty\;beam}^{-1}]\)</span> are technically undefined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ntheta</strong> (<em>int</em>) – number of azimuthal wedges to use for the 1st null calculation. More wedges will result in a more accurate estimate of dirty beam area, but will also take longer.</p></li>
<li><p><strong>single_channel_estimate</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> (the default), use the area estimated from the first channel for all channels in the multi-channel image cube. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, calculate the beam area for all channels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(1D numpy array float) beam area for each channel in units of <span class="math notranslate nohighlight">\([\mathrm{arcsec}^{2}]\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.gridding.DirtyImager.get_dirty_image">
<span class="sig-name descname"><span class="pre">get_dirty_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'uniform'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taper_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Jy/beam'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_visibility_scatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_scatter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">beam_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/gridding.html#DirtyImager.get_dirty_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.gridding.DirtyImager.get_dirty_image" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the dirty image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weighting</strong> (<em>string</em>) – The type of cell averaging to perform. Choices of <code class="docutils literal notranslate"><span class="pre">&quot;natural&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;uniform&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;briggs&quot;</span></code>, following CASA tclean. If <code class="docutils literal notranslate"><span class="pre">&quot;briggs&quot;</span></code>, also specify a robust value.</p></li>
<li><p><strong>robust</strong> (<em>float</em>) – If <code class="docutils literal notranslate"><span class="pre">weighting='briggs'</span></code>, specify a robust value in the range [-2, 2]. <code class="docutils literal notranslate"><span class="pre">robust=-2</span></code> approxmately corresponds to uniform weighting and <code class="docutils literal notranslate"><span class="pre">robust=2</span></code> approximately corresponds to natural weighting.</p></li>
<li><p><strong>taper_function</strong> (<em>function reference</em>) – a function assumed to be of the form <span class="math notranslate nohighlight">\(f(u,v)\)</span> which calculates a prefactor in the range <span class="math notranslate nohighlight">\([0,1]\)</span> and premultiplies the visibility data. The function must assume that <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> will be supplied in units of <span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>. By default no taper is applied.</p></li>
<li><p><strong>unit</strong> (<em>string</em>) – what unit should the image be in. Default is <code class="docutils literal notranslate"><span class="pre">&quot;Jy/beam&quot;</span></code>. If <code class="docutils literal notranslate"><span class="pre">&quot;Jy/arcsec^2&quot;</span></code>, then the effective area of the dirty beam will be used to convert from <code class="docutils literal notranslate"><span class="pre">&quot;Jy/beam&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">&quot;Jy/arcsec^2&quot;</span></code>.</p></li>
<li><p><strong>check_visibility_scatter</strong> (<em>bool</em>) – whether the routine should check the standard deviation of visibilities in each within each <span class="math notranslate nohighlight">\(u,v\)</span> cell (<span class="math notranslate nohighlight">\(\mathrm{cell}_{i,j}\)</span>) defined by <code class="docutils literal notranslate"><span class="pre">self.coords</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>. A <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> will be raised if any cell has a scatter larger than <code class="docutils literal notranslate"><span class="pre">max_scatter</span></code>.</p></li>
<li><p><strong>max_scatter</strong> (<em>float</em>) – the maximum allowable standard deviation of visibility values in a given <span class="math notranslate nohighlight">\(u,v\)</span> cell (<span class="math notranslate nohighlight">\(\mathrm{cell}_{i,j}\)</span>) defined by <code class="docutils literal notranslate"><span class="pre">self.coords</span></code>. Defaults to a factor of 120%.</p></li>
<li><p><strong>**beam_kwargs</strong> – all additional keyword arguments passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">get_dirty_beam_area()</span></code> if <code class="docutils literal notranslate"><span class="pre">unit=&quot;Jy/arcsec^2&quot;</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2-tuple of (<code class="docutils literal notranslate"><span class="pre">image</span></code>, <code class="docutils literal notranslate"><span class="pre">beam</span></code>) where <code class="docutils literal notranslate"><span class="pre">image</span></code> is an (nchan, npix, npix) numpy array of the dirty image cube in units <code class="docutils literal notranslate"><span class="pre">unit</span></code>. <code class="docutils literal notranslate"><span class="pre">beam</span></code> is an numpy image cube with a dirty beam (PSF) for each channel. The units of the beam are always Jy/{dirty beam}, i.e., the peak of the beam is normalized to 1.0.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mpol.datasets">
<span id="datasets"></span><h2>Datasets<a class="headerlink" href="#module-mpol.datasets" title="Permalink to this headline">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mpol.datasets.index_vis">
<span class="sig-prename descclassname"><span class="pre">mpol.datasets.</span></span><span class="sig-name descname"><span class="pre">index_vis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">griddedDataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/datasets.html#index_vis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.index_vis" title="Permalink to this definition">#</a></dt>
<dd><p>Index model visibilities to same locations as a <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a>. Assumes that vis is “packed” just like the <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>torch complex tensor</em>) – torch tensor with shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code> to be indexed by the <code class="docutils literal notranslate"><span class="pre">mask</span></code> from <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a>. Assumes tensor is “pre-packed.”</p></li>
<li><p><strong>griddedDataset</strong> – instantiated <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1d torch tensor of model samples collapsed across cube dimensions like <code class="docutils literal notranslate"><span class="pre">vis_indexed</span></code> and <code class="docutils literal notranslate"><span class="pre">weight_indexed</span></code> of <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch complex tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.datasets.GriddedDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.datasets.</span></span><span class="sig-name descname"><span class="pre">GriddedDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><span class="pre">GridCoords</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vis_gridded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_gridded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchan</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/datasets.html#GriddedDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.GriddedDataset" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>vis_gridded</strong> (<em>torch complex</em>) – the gridded visibility data stored in a “packed” format (pre-shifted for fft)</p></li>
<li><p><strong>weight_gridded</strong> (<em>torch double</em>) – the weights corresponding to the gridded visibility data, also in a packed format</p></li>
<li><p><strong>mask</strong> (<em>torch boolean</em>) – a boolean mask to index the non-zero locations of <code class="docutils literal notranslate"><span class="pre">vis_gridded</span></code> and <code class="docutils literal notranslate"><span class="pre">weight_gridded</span></code> in their packed format.</p></li>
<li><p><strong>nchan</strong> (<em>int</em>) – the number of channels in the image (default = 1).</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – the desired device of the dataset. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defalts to current device.</p></li>
</ul>
</dd>
</dl>
<p>After initialization, the GriddedDataset provides the non-zero cells of the gridded visibilities and weights as a 1D vector via the following instance variables. This means that any individual channel information has been collapsed.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis_indexed</strong> – 1D complex tensor of visibility data</p></li>
<li><p><strong>weight_indexd</strong> – 1D tensor of weight values</p></li>
</ul>
</dd>
</dl>
<p>If you index the output of the Fourier layer in the same manner using <code class="docutils literal notranslate"><span class="pre">self.mask</span></code>, then the model and data visibilities can be directly compared using a loss function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.datasets.GriddedDataset.from_image_properties">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_image_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vis_gridded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_gridded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchan</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/datasets.html#GriddedDataset.from_image_properties"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.GriddedDataset.from_image_properties" title="Permalink to this definition">#</a></dt>
<dd><p>Alternative method to instantiate a GriddedDataset object from cell_size and npix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the width of a pixel [arcseconds]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side</p></li>
<li><p><strong>vis_gridded</strong> (<em>torch complex</em>) – the gridded visibility data stored in a “packed” format (pre-shifted for fft)</p></li>
<li><p><strong>weight_gridded</strong> (<em>torch double</em>) – the weights corresponding to the gridded visibility data, also in a packed format</p></li>
<li><p><strong>mask</strong> (<em>torch boolean</em>) – a boolean mask to index the non-zero locations of <code class="docutils literal notranslate"><span class="pre">vis_gridded</span></code> and <code class="docutils literal notranslate"><span class="pre">weight_gridded</span></code> in their packed format.</p></li>
<li><p><strong>nchan</strong> (<em>int</em>) – the number of channels in the image (default = 1).</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – the desired device of the dataset. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defalts to current device.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.datasets.GriddedDataset.add_mask">
<span class="sig-name descname"><span class="pre">add_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ArrayLike</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/mpol/datasets.html#GriddedDataset.add_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.GriddedDataset.add_mask" title="Permalink to this definition">#</a></dt>
<dd><p>Apply an additional mask to the data. Only works as a data limiting operation (i.e., <code class="docutils literal notranslate"><span class="pre">mask</span></code> is more restrictive than the mask already attached to the dataset).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<em>2D numpy</em><em> or </em><em>PyTorch tensor</em>) – boolean mask (in packed format) to apply to dataset. Assumes input will be broadcast across all channels. Mask must be Hermitian, like the visibilities themselves.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – the desired device of the dataset. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defalts to current device.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.datasets.GriddedDataset.ground_mask">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ground_mask</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">torch.Tensor</span></em><a class="headerlink" href="#mpol.datasets.GriddedDataset.ground_mask" title="Permalink to this definition">#</a></dt>
<dd><p>The boolean mask, arranged in ground format.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3D mask cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.datasets.GriddedDataset.to">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">torch.device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><span class="pre">GriddedDataset</span></a></span></span><a class="reference internal" href="_modules/mpol/datasets.html#GriddedDataset.to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.GriddedDataset.to" title="Permalink to this definition">#</a></dt>
<dd><p>Moves the tensors of the dataset to specified device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>device</strong> (<em>torch.device</em>) – the desired device</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>copy of the GriddedDataset instance on the new device</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.datasets.UVDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.datasets.</span></span><span class="sig-name descname"><span class="pre">UVDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/datasets.html#UVDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.UVDataset" title="Permalink to this definition">#</a></dt>
<dd><p>Container for loose interferometric visibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uu</strong> (<em>2d numpy array</em>) – (nchan, nvis) length array of u spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vv</strong> (<em>2d numpy array</em>) – (nchan, nvis) length array of v spatial frequency coordinates. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>data_re</strong> (<em>2d numpy array</em>) – (nchan, nvis) length array of the real part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
<li><p><strong>data_im</strong> (<em>2d numpy array</em>) – (nchan, nvis) length array of the imaginary part of the visibility measurements. Units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\)</span>]</p></li>
<li><p><strong>weights</strong> (<em>2d numpy array</em>) – (nchan, nvis) length array of thermal weights. Units of [<span class="math notranslate nohighlight">\(1/\mathrm{Jy}^2\)</span>]</p></li>
<li><p><strong>cell_size</strong> (<em>float</em>) – the image pixel size in arcsec. Defaults to None, but if both <cite>cell_size</cite> and <cite>npix</cite> are set, the visibilities will be pre-gridded to the RFFT output dimensions.</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side (square images only). Defaults to None, but if both <cite>cell_size</cite> and <cite>npix</cite> are set, the visibilities will be pre-gridded to the RFFT output dimensions.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – the desired device of the dataset. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defalts to current device.</p></li>
</ul>
</dd>
</dl>
<p>If both <cite>cell_size</cite> and <cite>npix</cite> are set, the dataset will be automatically pre-gridded to the RFFT output grid. This will greatly speed up performance.</p>
<p>If you have just a single channel, you can pass 1D numpy arrays for <cite>uu</cite>, <cite>vv</cite>, <cite>weights</cite>, <cite>data_re</cite>, and <cite>data_im</cite> and they will automatically be promoted to 2D with a leading dimension of 1 (i.e., <code class="docutils literal notranslate"><span class="pre">nchan=1</span></code>).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.datasets.Dartboard">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.datasets.</span></span><span class="sig-name descname"><span class="pre">Dartboard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><span class="pre">GridCoords</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/datasets.html#Dartboard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.Dartboard" title="Permalink to this definition">#</a></dt>
<dd><p>A polar coordinate grid relative to a <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridCoords</span></code></a> object, reminiscent of a dartboard layout. The main utility of this object is to support splitting a dataset along radial and azimuthal bins for k-fold cross validation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>q_edges</strong> (<em>1D numpy array</em>) – an array of radial bin edges to set the dartboard cells in <span class="math notranslate nohighlight">\([\mathrm{k}\lambda]\)</span>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 12 log-linearly radial bins stretching from 0 to the <span class="math notranslate nohighlight">\(q_\mathrm{max}\)</span> represented by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p></li>
<li><p><strong>phi_edges</strong> (<em>1D numpy array</em>) – an array of azimuthal bin edges to set the dartboard cells in [radians], over the domain <span class="math notranslate nohighlight">\([0, \pi]\)</span>, which is also implicitly mapped to the domain <span class="math notranslate nohighlight">\([-\pi, \pi]\)</span> to preserve the Hermitian nature of the visibilities. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 8 equal-spaced azimuthal bins stretched from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(\pi\)</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.datasets.Dartboard.from_image_properties">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_image_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mpol.datasets.Dartboard" title="mpol.datasets.Dartboard"><span class="pre">Dartboard</span></a></span></span><a class="reference internal" href="_modules/mpol/datasets.html#Dartboard.from_image_properties"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.Dartboard.from_image_properties" title="Permalink to this definition">#</a></dt>
<dd><p>Alternative method to instantiate a Dartboard object from cell_size
and npix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the width of a pixel [arcseconds]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side</p></li>
<li><p><strong>q_edges</strong> (<em>1D numpy array</em>) – an array of radial bin edges to set the dartboard cells in <span class="math notranslate nohighlight">\([\mathrm{k}\lambda]\)</span>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 12 log-linearly radial bins stretching from 0 to the <span class="math notranslate nohighlight">\(q_\mathrm{max}\)</span> represented by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p></li>
<li><p><strong>phi_edges</strong> (<em>1D numpy array</em>) – an array of azimuthal bin edges to set the dartboard cells in [radians], over the domain <span class="math notranslate nohighlight">\([0, \pi]\)</span>, which is also implicitly mapped to the domain <span class="math notranslate nohighlight">\([-\pi, \pi]\)</span> to preserve the Hermitian nature of the visibilities. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 8 equal-spaced azimuthal bins stretched from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(\pi\)</span>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.datasets.Dartboard.get_polar_histogram">
<span class="sig-name descname"><span class="pre">get_polar_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/mpol/datasets.html#Dartboard.get_polar_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.Dartboard.get_polar_histogram" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate a histogram in polar coordinates, using the bin edges defined by <code class="docutils literal notranslate"><span class="pre">q_edges</span></code> and <code class="docutils literal notranslate"><span class="pre">phi_edges</span></code> during initialization.
Data coordinates should include the points for the Hermitian visibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qs</strong> – 1d array of q values <span class="math notranslate nohighlight">\([\mathrm{k}\lambda]\)</span></p></li>
<li><p><strong>phis</strong> – 1d array of datapoint azimuth values [radians] (must be the same length as qs)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d integer numpy array of cell counts, i.e., how many datapoints fell into each dartboard cell.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.datasets.Dartboard.get_nonzero_cell_indices">
<span class="sig-name descname"><span class="pre">get_nonzero_cell_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">integer</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/mpol/datasets.html#Dartboard.get_nonzero_cell_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.Dartboard.get_nonzero_cell_indices" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of the cell indices that contain data points, using the bin edges defined by <code class="docutils literal notranslate"><span class="pre">q_edges</span></code> and <code class="docutils literal notranslate"><span class="pre">phi_edges</span></code> during initialization.
Data coordinates should include the points for the Hermitian visibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qs</strong> – 1d array of q values <span class="math notranslate nohighlight">\([\mathrm{k}\lambda]\)</span></p></li>
<li><p><strong>phis</strong> – 1d array of datapoint azimuth values [radians] (must be the same length as qs)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of cell indices where cell contains at least one datapoint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.datasets.Dartboard.build_grid_mask_from_cells">
<span class="sig-name descname"><span class="pre">build_grid_mask_from_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_index_list</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">integer</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">np.bool_</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/mpol/datasets.html#Dartboard.build_grid_mask_from_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.datasets.Dartboard.build_grid_mask_from_cells" title="Permalink to this definition">#</a></dt>
<dd><p>Create a boolean mask of size <code class="docutils literal notranslate"><span class="pre">(npix,</span> <span class="pre">npix)</span></code> (in packed format) corresponding to the <code class="docutils literal notranslate"><span class="pre">vis_gridded</span></code> and <code class="docutils literal notranslate"><span class="pre">weight_gridded</span></code> quantities of the <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cell_index_list</strong> (<em>list</em>) – list or iterable containing [q_cell, phi_cell] index pairs to include in the mask.</p>
</dd>
</dl>
<p>Returns: (numpy array) 2D boolean mask in packed format.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-mpol.images">
<span id="images"></span><h2>Images<a class="headerlink" href="#module-mpol.images" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">images</span></code> module provides the core functionality of MPoL via <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.images.ImageCube</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mpol.images.BaseCube">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.images.</span></span><span class="sig-name descname"><span class="pre">BaseCube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixel_mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_cube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/images.html#BaseCube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.images.BaseCube" title="Permalink to this definition">#</a></dt>
<dd><p>A base cube of the same dimensions as the image cube. Designed to use a pixel mapping function <span class="math notranslate nohighlight">\(f_\mathrm{map}\)</span> from the base cube values to the ImageCube domain.</p>
<div class="math notranslate nohighlight">
\[I = f_\mathrm{map}(b)\]</div>
<p>The <code class="docutils literal notranslate"><span class="pre">base_cube</span></code> pixel values are set as PyTorch <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.parameter.Parameter.html">parameters</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the width of a pixel [arcseconds]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side</p></li>
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>nchan</strong> (<em>int</em>) – the number of channels in the base cube. Default = 1.</p></li>
<li><p><strong>pixel_mapping</strong> (<em>torch.nn</em>) – a PyTorch function mapping the base pixel representation to the cube representation. If <cite>None</cite>, defaults to <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Softplus.html#torch.nn.Softplus">torch.nn.Softplus()</a>. Output of the function should be in units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\,\mathrm{arcsec}^{-2}\)</span>].</p></li>
<li><p><strong>base_cube</strong> (<em>torch.double tensor</em><em>, </em><em>optional</em>) – a pre-packed base cube to initialize the model with. If None, assumes <code class="docutils literal notranslate"><span class="pre">torch.zeros</span></code>. See <a class="reference internal" href="units-and-conventions.html#cube-orientation-label"><span class="std std-ref">Image Cube Packing for FFTs</span></a> for more information on the expectations of the orientation of the input image.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.images.BaseCube.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/images.html#BaseCube.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.images.BaseCube.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the image representation from the <code class="docutils literal notranslate"><span class="pre">base_cube</span></code> using the pixel mapping</p>
<div class="math notranslate nohighlight">
\[I = f_\mathrm{map}(b)\]</div>
<p>Returns : an image cube in units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\,\mathrm{arcsec}^{-2}\)</span>].</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.images.HannConvCube">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.images.</span></span><span class="sig-name descname"><span class="pre">HannConvCube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nchan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requires_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/images.html#HannConvCube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.images.HannConvCube" title="Permalink to this definition">#</a></dt>
<dd><p>This convolutional layer convolves an input cube by a small 3x3 filter with shape</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
0.0625 &amp; 0.1250 &amp; 0.0625 \\
0.1250 &amp; 0.2500 &amp; 0.1250 \\
0.0625 &amp; 0.1250 &amp; 0.0625 \\
\end{bmatrix}\end{split}\]</div>
<p>which is the 2D version of the discretely-sampled response function corresponding to a Hann window, i.e., it is two 1D Hann windows multiplied together. This is a convolutional kernel in the image plane, and so effectively acts as apodization by a Hann window function in the Fourier domain. For more information, see the following Wikipedia articles on <a class="reference external" href="https://en.wikipedia.org/wiki/Window_function">Window Functions</a> in general and the <a class="reference external" href="https://en.wikipedia.org/wiki/Hann_function">Hann Window</a> specifically.</p>
<p>The idea is that this layer would help naturally attenuate high spatial frequency artifacts by baking in a natural apodization in the Fourier plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nchan</strong> (<em>int</em>) – number of channels</p></li>
<li><p><strong>requires_grad</strong> (<em>bool</em>) – keep kernel fixed</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.images.HannConvCube.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/images.html#HannConvCube.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.images.HannConvCube.forward" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cube</strong> (torch.double tensor, of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>) – a prepacked image cube, for example, from ImageCube.forward()</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the FFT of the image cube, in packed format and of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.complex tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.images.ImageCube">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.images.</span></span><span class="sig-name descname"><span class="pre">ImageCube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passthrough</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/images.html#ImageCube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.images.ImageCube" title="Permalink to this definition">#</a></dt>
<dd><p>The parameter set is the pixel values of the image cube itself. The pixels are assumed to represent samples of the specific intensity and are given in units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\,\mathrm{arcsec}^{-2}\)</span>].</p>
<p>All keyword arguments are required unless noted. The passthrough argument is essential for specifying whether the ImageCube object is the set of root parameters (<code class="docutils literal notranslate"><span class="pre">passthrough==False</span></code>) or if its simply a passthrough layer (<code class="docutils literal notranslate"><span class="pre">pasthrough==True</span></code>). In either case, ImageCube is essentially an identity layer, since no transformations are applied to the <code class="docutils literal notranslate"><span class="pre">cube</span></code> tensor. The main purpose of the ImageCube layer is to provide useful functionality around the <code class="docutils literal notranslate"><span class="pre">cube</span></code> tensor, such as returning a sky_cube representation and providing FITS writing functionility. In the case of <code class="docutils literal notranslate"><span class="pre">passthrough==False</span></code>, the ImageCube layer also acts as a container for the trainable parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the width of a pixel [arcseconds]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side</p></li>
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>nchan</strong> (<em>int</em>) – the number of channels in the image</p></li>
<li><p><strong>passthrough</strong> (<em>bool</em>) – if passthrough, assume ImageCube is just a layer as opposed to parameter base.</p></li>
<li><p><strong>cube</strong> (torch.double tensor, of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>) – (optional) a prepacked image cube to initialize the model with in units of [<span class="math notranslate nohighlight">\(\mathrm{Jy}\,\mathrm{arcsec}^{-2}\)</span>]. If None, assumes starting <code class="docutils literal notranslate"><span class="pre">cube</span></code> is <code class="docutils literal notranslate"><span class="pre">torch.zeros</span></code>. See <a class="reference internal" href="units-and-conventions.html#cube-orientation-label"><span class="std std-ref">Image Cube Packing for FFTs</span></a> for more information on the expectations of the orientation of the input image.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.images.ImageCube.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/images.html#ImageCube.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.images.ImageCube.forward" title="Permalink to this definition">#</a></dt>
<dd><p>If the ImageCube object was initialized with <code class="docutils literal notranslate"><span class="pre">passthrough=True</span></code>, the <code class="docutils literal notranslate"><span class="pre">cube</span></code> argument is required. <code class="docutils literal notranslate"><span class="pre">forward</span></code> essentially just passes this on as an identity operation.</p>
<p>If the ImageCube object was initialized with <code class="docutils literal notranslate"><span class="pre">passthrough=False</span></code>, the <code class="docutils literal notranslate"><span class="pre">cube</span></code> argument is not permitted, and <code class="docutils literal notranslate"><span class="pre">forward</span></code> passes on the stored <code class="docutils literal notranslate"><span class="pre">nn.Parameter</span></code> cube as an identity operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cube</strong> (3D torch tensor of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>) – only permitted if the ImageCube object was initialized with <code class="docutils literal notranslate"><span class="pre">passthrough=True</span></code>.</p>
</dd>
</dl>
<p>Returns: (3D torch.double tensor of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>) as identity operation</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.images.ImageCube.sky_cube">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sky_cube</span></span><a class="headerlink" href="#mpol.images.ImageCube.sky_cube" title="Permalink to this definition">#</a></dt>
<dd><p>The image cube arranged as it would appear on the sky.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3D image cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.images.ImageCube.to_FITS">
<span class="sig-name descname"><span class="pre">to_FITS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cube.fits'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/images.html#ImageCube.to_FITS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.images.ImageCube.to_FITS" title="Permalink to this definition">#</a></dt>
<dd><p>Export the image cube to a FITS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – the name of the FITS file to export to.</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em>) – if the file already exists, overwrite?</p></li>
<li><p><strong>header_kwargs</strong> (<em>dict</em>) – Extra keyword arguments to write to the FITS header.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mpol.fourier">
<span id="fourier"></span><h2>Fourier<a class="headerlink" href="#module-mpol.fourier" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">fourier</span></code> module provides the core functionality of MPoL via <a class="reference internal" href="#mpol.fourier.FourierCube" title="mpol.fourier.FourierCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.fourier.FourierCube</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mpol.fourier.FourierCube">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.fourier.</span></span><span class="sig-name descname"><span class="pre">FourierCube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">persistent_vis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#FourierCube"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.FourierCube" title="Permalink to this definition">#</a></dt>
<dd><p>This layer performs the FFT of an ImageCube and stores the corresponding dense FFT output as a cube. If you are using this layer in a forward-modeling RML workflow, because the FFT of the model is essentially stored as a grid, you will need to make the loss function calculation using a gridded loss function (e.g., <a class="reference internal" href="#mpol.losses.nll_gridded" title="mpol.losses.nll_gridded"><code class="xref py py-func docutils literal notranslate"><span class="pre">mpol.losses.nll_gridded()</span></code></a>) and a gridded dataset (e.g., <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.datasets.GriddedDataset</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the width of an image-plane pixel [arcseconds]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side</p></li>
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>persistent_vis</strong> (<em>Boolean</em>) – should the visibility cube be stored as part of the modules <cite>state_dict</cite>? If <cite>True</cite>, the state of the UV grid will be stored. It is recommended to use <cite>False</cite> for most applications, since the visibility cube will rarely be a direct parameter of the model.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.fourier.FourierCube.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#FourierCube.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.FourierCube.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Perform the FFT of the image cube on each channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cube</strong> (torch.double tensor, of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>) – a prepacked image cube, for example, from ImageCube.forward()</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the FFT of the image cube, in packed format.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(torch.complex tensor, of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.fourier.FourierCube.ground_vis">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ground_vis</span></span><a class="headerlink" href="#mpol.fourier.FourierCube.ground_vis" title="Permalink to this definition">#</a></dt>
<dd><p>The visibility cube in ground format cube fftshifted for plotting with <code class="docutils literal notranslate"><span class="pre">imshow</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the FFT of the image cube, in sky plane format.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(torch.complex tensor, of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.fourier.FourierCube.ground_amp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ground_amp</span></span><a class="headerlink" href="#mpol.fourier.FourierCube.ground_amp" title="Permalink to this definition">#</a></dt>
<dd><p>The amplitude of the cube, arranged in unpacked format corresponding to the FFT of the sky_cube. Array dimensions for plotting given by <code class="docutils literal notranslate"><span class="pre">self.coords.vis_ext</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3D amplitude cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.fourier.FourierCube.ground_phase">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ground_phase</span></span><a class="headerlink" href="#mpol.fourier.FourierCube.ground_phase" title="Permalink to this definition">#</a></dt>
<dd><p>The phase of the cube, arranged in unpacked format corresponding to the FFT of the sky_cube. Array dimensions for plotting given by <code class="docutils literal notranslate"><span class="pre">self.coords.vis_ext</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3D phase cube of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.fourier.safe_baseline_constant_meters">
<span class="sig-prename descclassname"><span class="pre">mpol.fourier.</span></span><span class="sig-name descname"><span class="pre">safe_baseline_constant_meters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv_cell_frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#safe_baseline_constant_meters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.safe_baseline_constant_meters" title="Permalink to this definition">#</a></dt>
<dd><p>This routine determines whether the baselines can safely be assumed to be constant with channel when they converted from meters to units of kilolambda.</p>
<p>The antenna baselines <em>are</em> the same as a function of channel when they are measured in physical distance units, such as meters. However, when these baselines are converted to spatial frequency units, via</p>
<div class="math notranslate nohighlight">
\[u = \frac{D}{\lambda},\]</div>
<p>it’s possible that the <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> values of each channel are significantly different if the <span class="math notranslate nohighlight">\(\lambda\)</span> values of each channel are significantly different. This routine evaluates whether the maximum change in <span class="math notranslate nohighlight">\(u\)</span> or <span class="math notranslate nohighlight">\(v\)</span> across channels (when represented in kilolambda) is smaller than some threshold value, calculated as the fraction of a <span class="math notranslate nohighlight">\(u,v\)</span> cell defined by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p>
<p>If this function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then it would be safe to proceed with parallelization in the <a class="reference internal" href="#mpol.fourier.NuFFT" title="mpol.fourier.NuFFT"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.fourier.NuFFT</span></code></a> layer via the coil dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uu</strong> (<em>1D np.array</em>) – a 1D array of length <code class="docutils literal notranslate"><span class="pre">nvis</span></code> array of the u (East-West) spatial frequency coordinate in units of [m]</p></li>
<li><p><strong>vv</strong> (<em>1D np.array</em>) – a 1D array of length <code class="docutils literal notranslate"><span class="pre">nvis</span></code> array of the v (North-South) spatial frequency coordinate in units of [m]</p></li>
<li><p><strong>freqs</strong> (<em>1D np.array</em>) – a 1D array of length <code class="docutils literal notranslate"><span class="pre">nchan</span></code> of the channel frequencies, in units of [Hz].</p></li>
<li><p><strong>coords</strong> – a <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.coordinates.GridCoords</span></code></a> object which represents the image and uv-grid dimensions.</p></li>
<li><p><strong>uv_cell_frac</strong> (<em>float</em>) – the maximum threshold for a change in <span class="math notranslate nohighlight">\(u\)</span> or <span class="math notranslate nohighlight">\(v\)</span> spatial frequency across channels, measured as a fraction of the <span class="math notranslate nohighlight">\(u,v\)</span> cell defined by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>True</cite> if it is safe to assume that the baselines are constant with channel (at a tolerance of <code class="docutils literal notranslate"><span class="pre">uv_cell_frac</span></code>.) Otherwise returns <cite>False</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.fourier.safe_baseline_constant_kilolambda">
<span class="sig-prename descclassname"><span class="pre">mpol.fourier.</span></span><span class="sig-name descname"><span class="pre">safe_baseline_constant_kilolambda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv_cell_frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#safe_baseline_constant_kilolambda"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.safe_baseline_constant_kilolambda" title="Permalink to this definition">#</a></dt>
<dd><p>This routine determines whether the baselines can safely be assumed to be constant with channel, when the are represented in units of kilolambda.</p>
<p>Compared to <a class="reference internal" href="#mpol.fourier.safe_baseline_constant_meters" title="mpol.fourier.safe_baseline_constant_meters"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.fourier.safe_baseline_constant_meters</span></code></a>, this function works with multidimensional arrays of <code class="docutils literal notranslate"><span class="pre">uu</span></code> and <code class="docutils literal notranslate"><span class="pre">vv</span></code> that are shape (nchan, nvis) and have units of kilolambda.</p>
<p>If this routine returns True, then it should be safe for the user to either average the baselines across channel or simply choose a single, representative channel. This would enable parallelization in the {class}`mpol.fourier.NuFFT` via the coil dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uu</strong> (<em>1D np.array</em>) – a 1D array of length <code class="docutils literal notranslate"><span class="pre">nvis</span></code> array of the u (East-West) spatial frequency coordinate in units of [m]</p></li>
<li><p><strong>vv</strong> (<em>1D np.array</em>) – a 1D array of length <code class="docutils literal notranslate"><span class="pre">nvis</span></code> array of the v (North-South) spatial frequency coordinate in units of [m]</p></li>
<li><p><strong>freqs</strong> (<em>1D np.array</em>) – a 1D array of length <code class="docutils literal notranslate"><span class="pre">nchan</span></code> of the channel frequencies, in units of [Hz].</p></li>
<li><p><strong>coords</strong> – a <a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.coordinates.GridCoords</span></code></a> object which represents the image and uv-grid dimensions.</p></li>
<li><p><strong>uv_cell_frac</strong> (<em>float</em>) – the maximum threshold for a change in <span class="math notranslate nohighlight">\(u\)</span> or <span class="math notranslate nohighlight">\(v\)</span> spatial frequency across channels, measured as a fraction of the <span class="math notranslate nohighlight">\(u,v\)</span> cell defined by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>True</cite> if it is safe to assume that the baselines are constant with channel (at a tolerance of <code class="docutils literal notranslate"><span class="pre">uv_cell_frac</span></code>.) Otherwise returns <cite>False</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.fourier.NuFFT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.fourier.</span></span><span class="sig-name descname"><span class="pre">NuFFT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#NuFFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.NuFFT" title="Permalink to this definition">#</a></dt>
<dd><p>This layer translates input from an <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.images.ImageCube</span></code></a> directly to loose, ungridded samples of the Fourier plane, directly corresponding to the <span class="math notranslate nohighlight">\(u,v\)</span> locations of the data. This layer is different than a <code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.Fourier.FourierCube</span></code> in that, rather than producing the dense cube-like output from an FFT routine, it utilizes the non-uniform FFT or ‘NuFFT’ to interpolate directly to discrete <span class="math notranslate nohighlight">\(u,v\)</span> locations that need not correspond to grid cell centers. This is implemented using the KbNufft routines of the <a class="reference external" href="https://torchkbnufft.readthedocs.io/en/stable/index.html">TorchKbNufft</a> package.</p>
<p><strong>Dimensionality</strong>: One consideration when using this layer is the dimensionality of your image and your visibility samples. If your image has multiple channels (<code class="docutils literal notranslate"><span class="pre">nchan</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>), there is the possibility that the <span class="math notranslate nohighlight">\(u,v\)</span> sample locations corresponding to each channel may be different. In ALMA/VLA applications, this can arise when continuum observations are taken over significant bandwidth, since the spatial frequency sampled by any pair of antennas is wavelength-dependent</p>
<div class="math notranslate nohighlight">
\[u = \frac{D}{\lambda},\]</div>
<p>where <span class="math notranslate nohighlight">\(D\)</span> is the projected baseline (measured in, say, meters) and <span class="math notranslate nohighlight">\(\lambda\)</span> is the observing wavelength. In this application, the image-plane model could be the same for each channel, or it may vary with channel (necessary if the spectral slope of the source is significant).</p>
<p>On the other hand, with spectral line observations it will usually be the case that the total bandwidth of the observations is small enough such that the <span class="math notranslate nohighlight">\(u,v\)</span> sample locations could be considered as the same for each channel. In spectral line applications, the image-plane model usually varies substantially with each channel.</p>
<p>This layer will determine whether the spatial frequencies are treated as constant based upon the dimensionality of the <code class="docutils literal notranslate"><span class="pre">uu</span></code> and <code class="docutils literal notranslate"><span class="pre">vv</span></code> input arguments.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">uu</span></code> and <code class="docutils literal notranslate"><span class="pre">vv</span></code> have a shape of (<code class="docutils literal notranslate"><span class="pre">nvis</span></code>), then it will be assumed that the spatial frequencies can be treated as constant with channel (and will invoke parallelization across the image cube <code class="docutils literal notranslate"><span class="pre">nchan</span></code> dimension using the ‘coil’ dimension of the TorchKbNufft package).</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">uu</span></code> and <code class="docutils literal notranslate"><span class="pre">vv</span></code> have a shape of (<code class="docutils literal notranslate"><span class="pre">nchan,</span> <span class="pre">nvis</span></code>), then it will be assumed that the spatial frequencies are different for each channel, and the spatial frequencies provided for each channel will be used (and will invoke parallelization across the image cube <code class="docutils literal notranslate"><span class="pre">nchan</span></code> dimension using the ‘batch’ dimension of the TorchKbNufft package).</p></li>
</ul>
<p>Note that there is no straightforward, computationally efficient way to proceed if there are a different number of spatial frequencies for each channel. The best approach is likely to construct <code class="docutils literal notranslate"><span class="pre">uu</span></code> and <code class="docutils literal notranslate"><span class="pre">vv</span></code> arrays that have a shape of (<code class="docutils literal notranslate"><span class="pre">nchan,</span> <span class="pre">nvis</span></code>), such that all channels are padded with bogus <span class="math notranslate nohighlight">\(u,v\)</span> points to have the same length <code class="docutils literal notranslate"><span class="pre">nvis</span></code>, and you create a boolean mask to keep track of which points are valid. Then, when this routine returns data points of shape (<code class="docutils literal notranslate"><span class="pre">nchan,</span> <span class="pre">nvis</span></code>), you can use that boolean mask to select only the valid <span class="math notranslate nohighlight">\(u,v\)</span> points points.</p>
<p><strong>Interpolation mode</strong>: You may choose the type of interpolation mode that KbNufft uses under the hood by changing the boolean value of <code class="docutils literal notranslate"><span class="pre">sparse_matrices</span></code>. For repeated evaluations of this layer (as might exist within an optimization loop), <code class="docutils literal notranslate"><span class="pre">sparse_matrices=True</span></code> is likely to be the more accurate and faster choice. If <code class="docutils literal notranslate"><span class="pre">sparse_matrices=False</span></code>, this routine will use the default table-based interpolation of TorchKbNufft. Note that as of TorchKbNuFFT version 1.4.0, sparse matrices are not yet available when parallelizing using the ‘batch’ dimension — this will result in a warning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the width of an image-plane pixel [arcseconds]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side</p></li>
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>nchan</strong> (<em>int</em>) – the number of channels in the <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.images.ImageCube</span></code></a>. Default = 1.</p></li>
<li><p><strong>uu</strong> (<em>np.array</em>) – a length <code class="docutils literal notranslate"><span class="pre">nvis</span></code> array (not including Hermitian pairs) of the u (East-West) spatial frequency coordinate [klambda]</p></li>
<li><p><strong>vv</strong> (<em>np.array</em>) – a length <code class="docutils literal notranslate"><span class="pre">nvis</span></code> array (not including Hermitian pairs) of the v (North-South) spatial frequency coordinate [klambda]</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.fourier.NuFFT.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#NuFFT.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.NuFFT.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Perform the FFT of the image cube for each channel and interpolate to the <code class="docutils literal notranslate"><span class="pre">uu</span></code> and <code class="docutils literal notranslate"><span class="pre">vv</span></code> points set at layer initialization. This call should automatically take the best parallelization option as indicated by the shape of the <code class="docutils literal notranslate"><span class="pre">uu</span></code> and <code class="docutils literal notranslate"><span class="pre">vv</span></code> points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cube</strong> (<em>torch.double tensor</em>) – of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code>). The cube should be a “prepacked” image cube, for example, from <a class="reference internal" href="#mpol.images.ImageCube.forward" title="mpol.images.ImageCube.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpol.images.ImageCube.forward()</span></code></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>of shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">nvis)</span></code>, Fourier samples evaluated corresponding to the <code class="docutils literal notranslate"><span class="pre">uu</span></code>, <code class="docutils literal notranslate"><span class="pre">vv</span></code> points set at initialization.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.complex tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.fourier.make_fake_data">
<span class="sig-prename descclassname"><span class="pre">mpol.fourier.</span></span><span class="sig-name descname"><span class="pre">make_fake_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imageCube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#make_fake_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.make_fake_data" title="Permalink to this definition">#</a></dt>
<dd><p>Create a fake dataset from a supplied <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">mpol.images.ImageCube</span></code></a>. See <a class="reference internal" href="ci-tutorials/fakedata.html#mock-dataset-label"><span class="std std-ref">Making a Mock Dataset</span></a> for more details on how to prepare a generic image for use in an <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageCube</span></code></a>.</p>
<p>The provided visibilities can be 1d for a single continuum channel, or 2d for image cube. If 1d, visibilities will be converted to 2d arrays of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">nvis)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imageCube</strong> (<a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageCube</span></code></a>) – the image layer to put into a fake dataset</p></li>
<li><p><strong>uu</strong> (<em>numpy array</em>) – array of u spatial frequency coordinates, not including Hermitian pairs. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>vv</strong> (<em>numpy array</em>) – array of v spatial frequency coordinates, not including Hermitian pairs. Units of [<span class="math notranslate nohighlight">\(\mathrm{k}\lambda\)</span>]</p></li>
<li><p><strong>weight</strong> (<em>2d numpy array</em>) – length array of thermal weights <span class="math notranslate nohighlight">\(w_i = 1/\sigma_i^2\)</span>. Units of [<span class="math notranslate nohighlight">\(1/\mathrm{Jy}^2\)</span>]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a two tuple of the fake data. The first array is the mock dataset including noise, the second array is the mock dataset without added noise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(2-tuple)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.fourier.get_vis_residuals">
<span class="sig-prename descclassname"><span class="pre">mpol.fourier.</span></span><span class="sig-name descname"><span class="pre">get_vis_residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/fourier.html#get_vis_residuals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.fourier.get_vis_residuals" title="Permalink to this definition">#</a></dt>
<dd><p>Use <cite>mpol.fourier.NuFFT</cite> to get residuals between gridded <cite>model</cite> and loose
(ungridded) data visiblities at data (u, v) coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<cite>torch.nn.Module</cite> object) – Instance of the <cite>mpol.precomposed.SimpleNet</cite> class. Contains model
visibilities.</p></li>
<li><p><strong>u_true</strong> (<em>array</em><em>, </em><em>unit=</em><em>[</em><em>klambda</em><em>]</em>) – Data u- and v-coordinates</p></li>
<li><p><strong>v_true</strong> (<em>array</em><em>, </em><em>unit=</em><em>[</em><em>klambda</em><em>]</em>) – Data u- and v-coordinates</p></li>
<li><p><strong>V_true</strong> (<em>array</em><em>, </em><em>unit=</em><em>[</em><em>Jy</em><em>]</em>) – Data visibility amplitudes</p></li>
<li><p><strong>channel</strong> (<em>int</em><em>, </em><em>default=0</em>) – Channel (of <cite>model</cite>) to use to calculate residual visibilities</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vis_resid</strong> – Model loose residual visibility amplitudes of the form
Re(V) + 1j * Im(V)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of complex</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="precomposed-modules">
<h2>Precomposed Modules<a class="headerlink" href="#precomposed-modules" title="Permalink to this headline">#</a></h2>
<p>For convenience, we provide some “precomposed” <a class="reference external" href="https://pytorch.org/docs/stable/notes/modules.html">modules</a> which may be useful for simple imaging or modeling applications. In general, though, we encourage you to compose your own set of layers if your application requires it. The source code for a precomposed network can provide useful a starting point. We also recommend checking out the PyTorch documentation on <a class="reference external" href="https://pytorch.org/docs/stable/notes/modules.html">modules</a>.</p>
<span class="target" id="module-mpol.precomposed"></span><dl class="py class">
<dt class="sig sig-object py" id="mpol.precomposed.SimpleNet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.precomposed.</span></span><span class="sig-name descname"><span class="pre">SimpleNet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_cube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/precomposed.html#SimpleNet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.precomposed.SimpleNet" title="Permalink to this definition">#</a></dt>
<dd><p>A basic but fully functional network for RML imaging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_size</strong> (<em>float</em>) – the width of a pixel [arcseconds]</p></li>
<li><p><strong>npix</strong> (<em>int</em>) – the number of pixels per image side</p></li>
<li><p><strong>coords</strong> (<a class="reference internal" href="#mpol.coordinates.GridCoords" title="mpol.coordinates.GridCoords"><em>GridCoords</em></a>) – an object already instantiated from the GridCoords class. If providing this, cannot provide <code class="docutils literal notranslate"><span class="pre">cell_size</span></code> or <code class="docutils literal notranslate"><span class="pre">npix</span></code>.</p></li>
<li><p><strong>nchan</strong> (<em>int</em>) – the number of channels in the base cube. Default = 1.</p></li>
<li><p><strong>base_cube</strong> – a pre-packed base cube to initialize the model with. If None, assumes <code class="docutils literal notranslate"><span class="pre">torch.zeros</span></code>.</p></li>
</ul>
</dd>
</dl>
<p>After the object is initialized, instance variables can be accessed, for example</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bcube</strong> – the <a class="reference internal" href="#mpol.images.BaseCube" title="mpol.images.BaseCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseCube</span></code></a> instance</p></li>
<li><p><strong>icube</strong> – the <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageCube</span></code></a> instance</p></li>
<li><p><strong>fcube</strong> – the <a class="reference internal" href="#mpol.fourier.FourierCube" title="mpol.fourier.FourierCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">FourierCube</span></code></a> instance</p></li>
</ul>
</dd>
</dl>
<p>For example, you’ll likely want to access the <code class="docutils literal notranslate"><span class="pre">self.icube.sky_model</span></code> at some point.</p>
<p>The idea is that <a class="reference internal" href="#mpol.precomposed.SimpleNet" title="mpol.precomposed.SimpleNet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleNet</span></code></a> can save you some keystrokes composing models by connecting the most commonly used layers together.</p>
<div class="mermaid">
            graph TD
    subgraph SimpleNet
    bc(BaseCube) --&gt; HannConvCube
    HannConvCube --&gt; ImageCube
    ImageCube --&gt; FourierLayer
    end
    FourierLayer --&gt; il([Loss])
    ad[[Dataset]] --&gt; il([Loss])

        </div><dl class="py method">
<dt class="sig sig-object py" id="mpol.precomposed.SimpleNet.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/precomposed.html#SimpleNet.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.precomposed.SimpleNet.forward" title="Permalink to this definition">#</a></dt>
<dd><p>Feed forward to calculate the model visibilities. In this step, a <a class="reference internal" href="#mpol.images.BaseCube" title="mpol.images.BaseCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseCube</span></code></a> is fed to a <a class="reference internal" href="#mpol.images.HannConvCube" title="mpol.images.HannConvCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">HannConvCube</span></code></a> is fed to a <a class="reference internal" href="#mpol.images.ImageCube" title="mpol.images.ImageCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">ImageCube</span></code></a> is fed to a <a class="reference internal" href="#mpol.fourier.FourierCube" title="mpol.fourier.FourierCube"><code class="xref py py-class docutils literal notranslate"><span class="pre">FourierCube</span></code></a> to produce the visibility cube.</p>
<p>Returns: 1D complex torch tensor of model visibilities.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-mpol.losses">
<span id="losses"></span><h2>Losses<a class="headerlink" href="#module-mpol.losses" title="Permalink to this headline">#</a></h2>
<p>The following loss functions are available to use in imaging. Many of the definitions follow those in Appendix A of <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...875L...4E/abstract">EHT-IV 2019</a>, including the regularization strength, which aspires to be similar across all terms, providing at least a starting point for tuning multiple loss functions.</p>
<p>If you don’t see a loss function you need, it’s easy to write your own directly within your optimization script. If you like it, please consider opening a pull request!</p>
<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.chi_squared">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">chi_squared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#chi_squared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.chi_squared" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the <span class="math notranslate nohighlight">\(\chi^2\)</span> between the complex data <span class="math notranslate nohighlight">\(\boldsymbol{V}\)</span> and model <span class="math notranslate nohighlight">\(M\)</span> visibilities using</p>
<div class="math notranslate nohighlight">
\[\chi^2(\boldsymbol{V}|\,\boldsymbol{\theta}) = \sum_i^N \frac{|V_i - M(u_i, v_i |\,\boldsymbol{\theta})|^2}{\sigma_i^2}\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_i^2 = 1/w_i\)</span>. The sum is over all of the provided visibilities. This function is agnostic as to whether the sum should include the Hermitian conjugate visibilities, but be aware that the answer returned will be different between the two cases. We recommend not including the Hermitian conjugates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model_vis</strong> (<em>PyTorch complex</em>) – array tuple of the model representing <span class="math notranslate nohighlight">\(\boldsymbol{V}\)</span></p></li>
<li><p><strong>data_vis</strong> (<em>PyTorch complex</em>) – array of the data values representing <span class="math notranslate nohighlight">\(M\)</span></p></li>
<li><p><strong>weight</strong> (<em>PyTorch real</em>) – array of weight values representing <span class="math notranslate nohighlight">\(w_i\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <span class="math notranslate nohighlight">\(\chi^2\)</span> likelihood</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.log_likelihood">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">log_likelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#log_likelihood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.log_likelihood" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the log likelihood function <span class="math notranslate nohighlight">\(\ln\mathcal{L}\)</span> between the complex data <span class="math notranslate nohighlight">\(\boldsymbol{V}\)</span> and model <span class="math notranslate nohighlight">\(M\)</span> visibilities using</p>
<div class="math notranslate nohighlight">
\[\ln \mathcal{L}(\boldsymbol{V}|\,\boldsymbol{\theta}) = - \left ( N \ln 2 \pi +  \sum_i^N \sigma_i^2 + \frac{1}{2} \chi^2(\boldsymbol{V}|\,\boldsymbol{\theta}) \right )\]</div>
<p>where <span class="math notranslate nohighlight">\(\chi^2\)</span> is evaluated using <a class="reference internal" href="#mpol.losses.chi_squared" title="mpol.losses.chi_squared"><code class="xref py py-func docutils literal notranslate"><span class="pre">mpol.losses.chi_squared()</span></code></a>.</p>
<p>This function is agnostic as to whether the sum should include the Hermitian conjugate visibilities, but be aware that the normalization of the answer returned will be different between the two cases. Inference of the parameter values should be unaffected. We recommend not including the Hermitian conjugates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model_vis</strong> (<em>PyTorch complex</em>) – array tuple of the model representing <span class="math notranslate nohighlight">\(\boldsymbol{V}\)</span></p></li>
<li><p><strong>data_vis</strong> (<em>PyTorch complex</em>) – array of the data values representing <span class="math notranslate nohighlight">\(M\)</span></p></li>
<li><p><strong>weight</strong> (<em>PyTorch real</em>) – array of weight values representing <span class="math notranslate nohighlight">\(w_i\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <span class="math notranslate nohighlight">\(\ln\mathcal{L}\)</span> log likelihood</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.nll">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">nll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#nll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.nll" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate a normalized “negative log likelihood” loss between the complex data <span class="math notranslate nohighlight">\(\boldsymbol{V}\)</span> and model <span class="math notranslate nohighlight">\(M\)</span> visibilities using</p>
<div class="math notranslate nohighlight">
\[L_\mathrm{nll} = \frac{1}{2 N} \chi^2(\boldsymbol{V}|\,\boldsymbol{\theta})\]</div>
<p>where <span class="math notranslate nohighlight">\(\chi^2\)</span> is evaluated using <a class="reference internal" href="#mpol.losses.chi_squared" title="mpol.losses.chi_squared"><code class="xref py py-func docutils literal notranslate"><span class="pre">mpol.losses.chi_squared()</span></code></a>. Visibilities may be any shape as long as all quantities have the same shape. Following <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...875L...4E/abstract">EHT-IV 2019</a>, we apply
a prefactor <span class="math notranslate nohighlight">\(1/(2 N)\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the number of visibilities. The factor of 2 comes in because we must count real and imaginaries in the <span class="math notranslate nohighlight">\(\chi^2\)</span> sum. This means that this normalized negative log likelihood loss function will have a minimum value of $L_mathrm{nll}(hat{boldsymbol{theta}}) approx 1$ for a well-fit model (regardless of the number of data points), making it easier to set the prefactor strengths of other regularizers <em>relative</em> to this value.</p>
<p>Note that this function should only be used in an optimization or point estimate situation. If it is used in any situation where uncertainties on parameter values are determined (such as Markov Chain Monte Carlo), it will return the wrong answer. This is because the relative scaling of <span class="math notranslate nohighlight">\(L_\mathrm{nll}\)</span> with respect to parameter value is incorrect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model_vis</strong> (<em>PyTorch complex</em>) – array tuple of the model representing <span class="math notranslate nohighlight">\(\boldsymbol{V}\)</span></p></li>
<li><p><strong>data_vis</strong> (<em>PyTorch complex</em>) – array of the data values representing <span class="math notranslate nohighlight">\(M\)</span></p></li>
<li><p><strong>weight</strong> (<em>PyTorch real</em>) – array of weight values representing <span class="math notranslate nohighlight">\(w_i\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the normalized negative log likelihood likelihood loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.chi_squared_gridded">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">chi_squared_gridded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">griddedDataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#chi_squared_gridded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.chi_squared_gridded" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the <span class="math notranslate nohighlight">\(\chi^2\)</span> (corresponding to <a class="reference internal" href="#mpol.losses.chi_squared" title="mpol.losses.chi_squared"><code class="xref py py-func docutils literal notranslate"><span class="pre">chi_squared()</span></code></a>) using gridded data and model visibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>torch complex tensor</em>) – torch tensor with shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code> to be indexed by the <code class="docutils literal notranslate"><span class="pre">mask</span></code> from <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a>. Assumes tensor is “pre-packed,” as in output from <a class="reference internal" href="#mpol.fourier.FourierCube.forward" title="mpol.fourier.FourierCube.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpol.fourier.FourierCube.forward()</span></code></a>.</p></li>
<li><p><strong>griddedDataset</strong> – instantiated <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <span class="math notranslate nohighlight">\(\chi^2\)</span> value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.log_likelihood_gridded">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">log_likelihood_gridded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">griddedDataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#log_likelihood_gridded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.log_likelihood_gridded" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the log likelihood function <span class="math notranslate nohighlight">\(\ln\mathcal{L}\)</span> (corresponding to <a class="reference internal" href="#mpol.losses.log_likelihood" title="mpol.losses.log_likelihood"><code class="xref py py-func docutils literal notranslate"><span class="pre">log_likelihood()</span></code></a>) using gridded data and model visibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>torch complex tensor</em>) – torch tensor with shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code> to be indexed by the <code class="docutils literal notranslate"><span class="pre">mask</span></code> from <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a>. Assumes tensor is “pre-packed,” as in output from <a class="reference internal" href="#mpol.fourier.FourierCube.forward" title="mpol.fourier.FourierCube.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpol.fourier.FourierCube.forward()</span></code></a>.</p></li>
<li><p><strong>griddedDataset</strong> – instantiated <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the <span class="math notranslate nohighlight">\(\ln\mathcal{L}\)</span> value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.nll_gridded">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">nll_gridded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datasetGridded</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#nll_gridded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.nll_gridded" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate a normalized “negative log likelihood” (corresponding to <a class="reference internal" href="#mpol.losses.nll" title="mpol.losses.nll"><code class="xref py py-func docutils literal notranslate"><span class="pre">nll()</span></code></a>) using gridded data and model visibilities. Function will return the same value regardless of whether Hermitian pairs are included.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>torch complex tensor</em>) – torch tensor with shape <code class="docutils literal notranslate"><span class="pre">(nchan,</span> <span class="pre">npix,</span> <span class="pre">npix)</span></code> to be indexed by the <code class="docutils literal notranslate"><span class="pre">mask</span></code> from <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a>. Assumes tensor is “pre-packed,” as in output from <a class="reference internal" href="#mpol.fourier.FourierCube.forward" title="mpol.fourier.FourierCube.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mpol.fourier.FourierCube.forward()</span></code></a>.</p></li>
<li><p><strong>griddedDataset</strong> – instantiated <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the normalized negative log likelihood likelihood loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.entropy">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prior_intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.entropy" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the entropy loss of a set of pixels following the definition in <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...875L...4E/abstract">EHT-IV 2019</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cube</strong> (<em>any tensor</em>) – pixel values must be positive <span class="math notranslate nohighlight">\(I_i &gt; 0\)</span> for all <span class="math notranslate nohighlight">\(i\)</span></p></li>
<li><p><strong>prior_intensity</strong> (<em>any tensor</em>) – the prior value <span class="math notranslate nohighlight">\(p\)</span> to calculate entropy against. Could be a single constant or an array the same shape as image.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>entropy loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
<p>The entropy loss is calculated as</p>
<div class="math notranslate nohighlight">
\[L = \frac{1}{\sum_i I_i} \sum_i I_i \; \ln \frac{I_i}{p_i}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.TV_image">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">TV_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sky_cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#TV_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.TV_image" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the total variation (TV) loss in the image dimension (R.A. and DEC). Following the definition in <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...875L...4E/abstract">EHT-IV 2019</a> Promotes the image to be piecewise smooth and the gradient of the image to be sparse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sky_cube</strong> (<em>any 3D tensor</em>) – the image cube array <span class="math notranslate nohighlight">\(I_{lmv}\)</span>, where <span class="math notranslate nohighlight">\(l\)</span> is R.A. in <span class="math notranslate nohighlight">\(ndim=3\)</span>, <span class="math notranslate nohighlight">\(m\)</span> is DEC in <span class="math notranslate nohighlight">\(ndim=2\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> is the channel (velocity or frequency) dimension in <span class="math notranslate nohighlight">\(ndim=1\)</span>. Should be in sky format representation.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – a softening parameter in [<span class="math notranslate nohighlight">\(\mathrm{Jy}/\mathrm{arcsec}^2\)</span>]. Any pixel-to-pixel variations within each image slice greater than this parameter will have a significant penalty.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>total variation loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[L = \sum_{l,m,v} \sqrt{(I_{l + 1, m, v} - I_{l,m,v})^2 + (I_{l, m+1, v} - I_{l, m, v})^2 + \epsilon}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.TV_channel">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">TV_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#TV_channel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.TV_channel" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the total variation (TV) loss in the channel dimension. Following the definition in <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...875L...4E/abstract">EHT-IV 2019</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cube</strong> (<em>any 3D tensor</em>) – the image cube array <span class="math notranslate nohighlight">\(I_{lmv}\)</span></p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – a softening parameter in [<span class="math notranslate nohighlight">\(\mathrm{Jy}/\mathrm{arcsec}^2\)</span>]. Any channel-to-channel pixel variations greater than this parameter will have a significant penalty.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>total variation loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[L = \sum_{l,m,v} \sqrt{(I_{l, m, v + 1} - I_{l,m,v})^2 + \epsilon}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.edge_clamp">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">edge_clamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#edge_clamp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.edge_clamp" title="Permalink to this definition">#</a></dt>
<dd><p>Promote all pixels at the edge of the image to be zero using an <span class="math notranslate nohighlight">\(L_2\)</span> norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cube</strong> (<em>any 3D tensor</em>) – the array and pixel values</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>edge loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.sparsity">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">sparsity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cube</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#sparsity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.sparsity" title="Permalink to this definition">#</a></dt>
<dd><p>Enforce a sparsity prior on the image cube using the <span class="math notranslate nohighlight">\(L_1\)</span> norm. Optionally provide a boolean mask to apply the prior to only the <code class="docutils literal notranslate"><span class="pre">True</span></code> locations. For example, you might want this mask to be <code class="docutils literal notranslate"><span class="pre">True</span></code> for background regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cube</strong> (<em>nchan</em><em>, </em><em>npix</em><em>, </em><em>npix</em>) – tensor image cube</p></li>
<li><p><strong>mask</strong> (<em>boolean</em>) – tensor array the same shape as <code class="docutils literal notranslate"><span class="pre">cube</span></code>. The sparsity prior will be applied to those pixels where the mask is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Default is to apply prior to all pixels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sparsity loss calculated where <code class="docutils literal notranslate"><span class="pre">mask</span> <span class="pre">==</span> <span class="pre">True</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
<p>The sparsity loss calculated as</p>
<div class="math notranslate nohighlight">
\[L = \sum_i | I_i |\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.UV_sparsity">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">UV_sparsity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_max</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#UV_sparsity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.UV_sparsity" title="Permalink to this definition">#</a></dt>
<dd><p>Enforce a sparsity prior for all <span class="math notranslate nohighlight">\(q = \sqrt{u^2 + v^2}\)</span> points larger than <span class="math notranslate nohighlight">\(q_\mathrm{max}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>torch.double</em>) – visibility cube of (nchan, npix, npix//2 +1, 2)</p></li>
<li><p><strong>qs</strong> – numpy array corresponding to visibility coordinates. Dimensionality of (npix, npix//2)</p></li>
<li><p><strong>q_max</strong> (<em>float</em>) – maximum radial baseline</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>UV sparsity loss above <span class="math notranslate nohighlight">\(q_\mathrm{max}\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.PSD">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">PSD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#PSD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.PSD" title="Permalink to this definition">#</a></dt>
<dd><p>Apply a loss function corresponding to the power spectral density using a Gaussian process kernel.</p>
<p>Assumes an image plane kernel of</p>
<div class="math notranslate nohighlight">
\[k(r) = exp(-\frac{r^2}{2 \ell^2})\]</div>
<p>The corresponding power spectral density is</p>
<div class="math notranslate nohighlight">
\[P(q) = (2 \pi \ell^2) exp(- 2 \pi^2 \ell^2 q^2)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qs</strong> (<em>torch.double</em>) – the radial UV coordinate (in kilolambda)</p></li>
<li><p><strong>psd</strong> (<em>torch.double</em>) – the power spectral density cube</p></li>
<li><p><strong>l</strong> (<em>torch.double</em>) – the correlation length in the image plane (in arcsec)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the loss calculated using the power spectral density</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.losses.TSV">
<span class="sig-prename descclassname"><span class="pre">mpol.losses.</span></span><span class="sig-name descname"><span class="pre">TSV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sky_cube</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/losses.html#TSV"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.losses.TSV" title="Permalink to this definition">#</a></dt>
<dd><p>Calculate the total square variation (TSV) loss in the image dimension (R.A. and DEC). Following the definition in <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...875L...4E/abstract">EHT-IV 2019</a> Promotes the image to be edge smoothed which may be a better reoresentation of the truth image <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2018ApJ...858...56K/abstract">K. Kuramochi et al 2018</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sky_cube</strong> (<em>any 3D tensor</em>) – the image cube array <span class="math notranslate nohighlight">\(I_{lmv}\)</span>, where <span class="math notranslate nohighlight">\(l\)</span> is R.A. in <span class="math notranslate nohighlight">\(ndim=3\)</span>, <span class="math notranslate nohighlight">\(m\)</span> is DEC in <span class="math notranslate nohighlight">\(ndim=2\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> is the channel (velocity or frequency) dimension in <span class="math notranslate nohighlight">\(ndim=1\)</span>. Should be in sky format representation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>total square variation loss</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[L = \sum_{l,m,v} (I_{l + 1, m, v} - I_{l,m,v})^2 + (I_{l, m+1, v} - I_{l, m, v})^2\]</div>
</dd></dl>

</section>
<section id="module-mpol.training">
<span id="training-and-testing"></span><h2>Training and testing<a class="headerlink" href="#module-mpol.training" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mpol.training.TrainTest">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.training.</span></span><span class="sig-name descname"><span class="pre">TrainTest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imager</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularizers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_diag_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kfold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/training.html#TrainTest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.training.TrainTest" title="Permalink to this definition">#</a></dt>
<dd><p>Utilities for training and testing an MPoL neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imager</strong> (<cite>mpol.gridding.DirtyImager</cite> object) – Instance of the <cite>mpol.gridding.DirtyImager</cite> class.</p></li>
<li><p><strong>optimizer</strong> (<cite>torch.optim</cite> object) – PyTorch optimizer class for the training loop.</p></li>
<li><p><strong>epochs</strong> (<em>int</em><em>, </em><em>default=10000</em>) – Number of training iterations</p></li>
<li><p><strong>convergence_tol</strong> (<em>float</em><em>, </em><em>default=1e-3</em>) – Tolerance for training iteration stopping criterion as assessed by
loss function (suggested &lt;= 1e-3)</p></li>
<li><p><strong>regularizers</strong> (<em>nested dict</em><em>, </em><em>default={}</em>) – <p>Dictionary of image regularizers to use. For each, a dict of the
strength (‘lambda’, float), whether to guess an initial value for lambda
(‘guess’, bool), and other quantities needed to compute their loss term.
Example:</p>
<blockquote>
<div><dl class="simple">
<dt>{“sparsity”:{“lambda”:1e-3, “guess”:False},</dt><dd><p>”entropy”: {“lambda”:1e-3, “guess”:True, “prior_intensity”:1e-10}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</p></li>
<li><p><strong>train_diag_step</strong> (<em>int</em><em>, </em><em>default=None</em>) – Interval at which training diagnostics are output. If None, no
diagnostics will be generated.</p></li>
<li><p><strong>kfold</strong> (<em>int</em><em>, </em><em>default=None</em>) – The k-fold of the current training set (for diagnostics)</p></li>
<li><p><strong>save_prefix</strong> (<em>str</em><em>, </em><em>default=None</em>) – Prefix (path) used for saved figure names. If None, figures won’t be
saved</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to print notification messages</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.training.TrainTest.loss_convergence">
<span class="sig-name descname"><span class="pre">loss_convergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loss</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/training.html#TrainTest.loss_convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.training.TrainTest.loss_convergence" title="Permalink to this definition">#</a></dt>
<dd><p>Estimate whether the loss function has converged by assessing its
relative change over recent iterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loss</strong> (<em>array</em>) – Values of loss function over iterations (epochs).
If len(loss) &lt; 11, <cite>False</cite> will be returned, as convergence
cannot be adequately assessed.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>True</cite> if the convergence criterion is met, else <cite>False</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.training.TrainTest.loss_lambda_guess">
<span class="sig-name descname"><span class="pre">loss_lambda_guess</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/training.html#TrainTest.loss_lambda_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.training.TrainTest.loss_lambda_guess" title="Permalink to this definition">#</a></dt>
<dd><p>Set an initial guess for regularizer strengths <span class="math notranslate nohighlight">\(\lambda_{x}\)</span> by
comparing images generated with different visibility weighting.</p>
<p>The guesses update <cite>lambda</cite> values in <cite>self._regularizers</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.training.TrainTest.loss_eval">
<span class="sig-name descname"><span class="pre">loss_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sky_cube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/training.html#TrainTest.loss_eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.training.TrainTest.loss_eval" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vis</strong> (<em>torch.complex tensor</em>) – Model visibility cube (see <cite>mpol.fourier.FourierCube.forward</cite>)</p></li>
<li><p><strong>dataset</strong> (<em>PyTorch dataset object</em>) – Instance of the <cite>mpol.datasets.GriddedDataset</cite> class.</p></li>
<li><p><strong>sky_cube</strong> (<em>torch.double</em>) – MPoL Ground Cube (see <cite>mpol.utils.packed_cube_to_ground_cube</cite>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>loss</strong> – Value of loss function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.training.TrainTest.train">
<span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/training.html#TrainTest.train"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.training.TrainTest.train" title="Permalink to this definition">#</a></dt>
<dd><p>Trains a neural network, forward modeling a visibility dataset and
evaluating the corresponding model image against the data, using
PyTorch with gradient descent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<cite>torch.nn.Module</cite> object) – A neural network; instance of the <cite>mpol.precomposed.SimpleNet</cite> class.</p></li>
<li><p><strong>dataset</strong> (<em>PyTorch dataset object</em>) – Instance of the <cite>mpol.datasets.GriddedDataset</cite> class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>loss.item()</strong> (<em>float</em>) – Value of loss function at end of optimization loop</p></li>
<li><p><strong>losses</strong> (<em>list of float</em>) – Loss value at each iteration (epoch) in the loop</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.training.TrainTest.test">
<span class="sig-name descname"><span class="pre">test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/training.html#TrainTest.test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.training.TrainTest.test" title="Permalink to this definition">#</a></dt>
<dd><p>Test a model visibility cube against withheld data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<cite>torch.nn.Module</cite> object) – A neural network; instance of the <cite>mpol.precomposed.SimpleNet</cite> class.</p></li>
<li><p><strong>dataset</strong> (<em>PyTorch dataset object</em>) – Instance of the <cite>mpol.datasets.GriddedDataset</cite> class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>loss.item()</strong> – Value of loss function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.training.TrainTest.regularizers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">regularizers</span></span><a class="headerlink" href="#mpol.training.TrainTest.regularizers" title="Permalink to this definition">#</a></dt>
<dd><p>Dict containing regularizers used and their strengths</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.training.TrainTest.train_figure">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">train_figure</span></span><a class="headerlink" href="#mpol.training.TrainTest.train_figure" title="Permalink to this definition">#</a></dt>
<dd><p>(fig, axes) of figure showing training diagnostics</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.training.TrainTest.train_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">train_state</span></span><a class="headerlink" href="#mpol.training.TrainTest.train_state" title="Permalink to this definition">#</a></dt>
<dd><p>Dict containing parameters of interest in the training loop</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-mpol.crossval">
<span id="cross-validation"></span><h2>Cross-validation<a class="headerlink" href="#module-mpol.crossval" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.crossval.</span></span><span class="sig-name descname"><span class="pre">CrossValidate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imager</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kfolds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random_cell'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learn_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularizers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_diag_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_diag_fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_cv_diagnostics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/crossval.html#CrossValidate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.crossval.CrossValidate" title="Permalink to this definition">#</a></dt>
<dd><p>Utilities to run a cross-validation loop (implicitly running a training
optimization loop), in order to compare MPoL models with different
hyperparameter values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<cite>mpol.coordinates.GridCoords</cite> object) – Instance of the <cite>mpol.coordinates.GridCoords</cite> class.</p></li>
<li><p><strong>imager</strong> (<cite>mpol.gridding.DirtyImager</cite> object) – Instance of the <cite>mpol.gridding.DirtyImager</cite> class.</p></li>
<li><p><strong>kfolds</strong> (<em>int</em><em>, </em><em>default=5</em>) – Number of k-folds to use in cross-validation</p></li>
<li><p><strong>split_method</strong> (<em>str</em><em>, </em><em>default='random_cell'</em>) – Method to split full dataset into train/test subsets</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default=None</em>) – Seed for random number generator used in splitting data</p></li>
<li><p><strong>learn_rate</strong> (<em>float</em><em>, </em><em>default=0.5</em>) – Neural network learning rate</p></li>
<li><p><strong>epochs</strong> (<em>int</em><em>, </em><em>default=10000</em>) – Number of training iterations</p></li>
<li><p><strong>convergence_tol</strong> (<em>float</em><em>, </em><em>default=1e-3</em>) – Tolerance for training iteration stopping criterion as assessed by
loss function (suggested &lt;= 1e-3)</p></li>
<li><p><strong>regularizers</strong> (<em>nested dict</em><em>, </em><em>default={}</em>) – <p>Dictionary of image regularizers to use. For each, a dict of the
strength (‘lambda’, float), whether to guess an initial value for lambda
(‘guess’, bool), and other quantities needed to compute their loss term.
Example:</p>
<blockquote>
<div><dl class="simple">
<dt>{“sparsity”:{“lambda”:1e-3, “guess”:False},</dt><dd><p>”entropy”: {“lambda”:1e-3, “guess”:True, “prior_intensity”:1e-10}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</p></li>
<li><p><strong>train_diag_step</strong> (<em>int</em><em>, </em><em>default=None</em>) – Interval at which training diagnostics are output. If None, no
diagnostics will be generated.</p></li>
<li><p><strong>split_diag_fig</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to generate a diagnostic figure of dataset splitting into
train/test sets.</p></li>
<li><p><strong>store_cv_diagnostics</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to store diagnostics of the cross-validation loop.</p></li>
<li><p><strong>save_prefix</strong> (<em>str</em><em>, </em><em>default=None</em>) – Prefix (path) used for saved figure names. If None, figures won’t be
saved</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em>, </em><em>default=None</em>) – Which hardware device to perform operations on (e.g., ‘cuda:0’).
‘None’ defaults to current device.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to print notification messages.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate.split_dataset">
<span class="sig-name descname"><span class="pre">split_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/crossval.html#CrossValidate.split_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.crossval.CrossValidate.split_dataset" title="Permalink to this definition">#</a></dt>
<dd><p>Split a dataset into training and test subsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dataset</strong> (<em>PyTorch dataset object</em>) – Instance of the <cite>mpol.datasets.GriddedDataset</cite> class</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>split_iterator</strong> – Iterator that provides a (train, test) pair of
<a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> for each k-fold</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iterator returning tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate.run_crossval">
<span class="sig-name descname"><span class="pre">run_crossval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/crossval.html#CrossValidate.run_crossval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.crossval.CrossValidate.run_crossval" title="Permalink to this definition">#</a></dt>
<dd><p>Run a cross-validation loop for a model obtained with a given set of
hyperparameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dataset</strong> (<em>PyTorch dataset object</em>) – Instance of the <cite>mpol.datasets.GriddedDataset</cite> class</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cv_score</strong> – Dictionary with mean and standard deviation of cross-validation
scores across all k-folds, and all raw scores</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#mpol.crossval.CrossValidate.model" title="Permalink to this definition">#</a></dt>
<dd><p>SimpleNet class instance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate.regularizers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">regularizers</span></span><a class="headerlink" href="#mpol.crossval.CrossValidate.regularizers" title="Permalink to this definition">#</a></dt>
<dd><p>Dict containing regularizers used and their strengths</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate.diagnostics">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">diagnostics</span></span><a class="headerlink" href="#mpol.crossval.CrossValidate.diagnostics" title="Permalink to this definition">#</a></dt>
<dd><p>Dict containing diagnostics of the cross-validation loop</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate.split_figure">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">split_figure</span></span><a class="headerlink" href="#mpol.crossval.CrossValidate.split_figure" title="Permalink to this definition">#</a></dt>
<dd><p>(fig, axes) of train/test splitting diagnostic figure</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mpol.crossval.CrossValidate.train_figure">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">train_figure</span></span><a class="headerlink" href="#mpol.crossval.CrossValidate.train_figure" title="Permalink to this definition">#</a></dt>
<dd><p>(fig, axes) of most recent training diagnostic figure</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.crossval.RandomCellSplitGridded">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.crossval.</span></span><span class="sig-name descname"><span class="pre">RandomCellSplitGridded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/crossval.html#RandomCellSplitGridded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.crossval.RandomCellSplitGridded" title="Permalink to this definition">#</a></dt>
<dd><p>Split a GriddedDataset into <span class="math notranslate nohighlight">\(k\)</span> subsets. Inherit the properties of
the GriddedDataset. This object creates an iterator providing a
(train, test) pair of <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> for each
k-fold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<em>PyTorch dataset object</em>) – Instance of the <cite>mpol.datasets.GriddedDataset</cite> class</p></li>
<li><p><strong>k</strong> (<em>int</em><em>, </em><em>default=5</em>) – Number of k-folds (partitions) of <cite>dataset</cite></p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default=None</em>) – Seed for PyTorch random number generator used to shuffle data before
splitting</p></li>
<li><p><strong>channel</strong> (<em>int</em><em>, </em><em>default=0</em>) – Channel of the dataset to use in determining the splits</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl>
<dt>Once initialized, iterate through the datasets like:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">split_iterator</span> <span class="o">=</span> <span class="n">crossval</span><span class="o">.</span><span class="n">RandomCellSplitGridded</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span> <span class="ow">in</span> <span class="n">split_iterator</span><span class="p">:</span> <span class="c1"># iterate through `k` datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># working with the n-th slice of `k` datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># do operations with train dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># do operations with test dataset</span>
</pre></div>
</div>
</dd>
</dl>
<p>Treats <cite>dataset</cite> as a single-channel object with all data in <cite>channel</cite>.</p>
<p>The splitting doesn’t select (preserve) Hermitian pairs of visibilities.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mpol.crossval.DartboardSplitGridded">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mpol.crossval.</span></span><span class="sig-name descname"><span class="pre">DartboardSplitGridded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridded_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><span class="pre">GriddedDataset</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dartboard</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#mpol.datasets.Dartboard" title="mpol.datasets.Dartboard"><span class="pre">Dartboard</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/crossval.html#DartboardSplitGridded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.crossval.DartboardSplitGridded" title="Permalink to this definition">#</a></dt>
<dd><p>Split a GriddedDataset into <span class="math notranslate nohighlight">\(k\)</span> non-overlapping chunks, internally partitioned by a Dartboard. Inherit the properties of the GriddedDataset. This object creates an iterator providing a (train, test) pair of <a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a> for each k-fold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>griddedDataset</strong> (<a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a>) – instance of the gridded dataset</p></li>
<li><p><strong>k</strong> (<em>int</em>) – the number of subpartitions of the dataset</p></li>
<li><p><strong>dartboard</strong> (<a class="reference internal" href="#mpol.datasets.Dartboard" title="mpol.datasets.Dartboard"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dartboard</span></code></a>) – a pre-initialized Dartboard instance. If <code class="docutils literal notranslate"><span class="pre">dartboard</span></code> is provided, do not provide <code class="docutils literal notranslate"><span class="pre">q_edges</span></code> or <code class="docutils literal notranslate"><span class="pre">phi_edges</span></code>.</p></li>
<li><p><strong>q_edges</strong> (<em>1D numpy array</em>) – an array of radial bin edges to set the dartboard cells in <span class="math notranslate nohighlight">\([\mathrm{k}\lambda]\)</span>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 12 log-linearly radial bins stretching from 0 to the <span class="math notranslate nohighlight">\(q_\mathrm{max}\)</span> represented by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p></li>
<li><p><strong>phi_edges</strong> (<em>1D numpy array</em>) – an array of azimuthal bin edges to set the dartboard cells in [radians]. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 8 equal-spaced azimuthal bins stretched from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(\pi\)</span>.</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – (optional) numpy random seed to use for the permutation, for reproducibility</p></li>
</ul>
</dd>
</dl>
<p>Once initialized, iterate through the datasets like</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">crossval</span><span class="o">.</span><span class="n">DartboardSplitGridded</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cv</span><span class="p">:</span> <span class="c1"># iterate among k datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># working with the n-th slice of k datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># do operations with train dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># do operations with test dataset</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mpol.crossval.DartboardSplitGridded.from_dartboard_properties">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_dartboard_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridded_dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><span class="pre">GriddedDataset</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NDArray</span><span class="p"><span class="pre">[</span></span><span class="pre">floating</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mpol.crossval.DartboardSplitGridded" title="mpol.crossval.DartboardSplitGridded"><span class="pre">DartboardSplitGridded</span></a></span></span><a class="reference internal" href="_modules/mpol/crossval.html#DartboardSplitGridded.from_dartboard_properties"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.crossval.DartboardSplitGridded.from_dartboard_properties" title="Permalink to this definition">#</a></dt>
<dd><p>Alternative method to initialize a DartboardSplitGridded object from Dartboard parameters.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>griddedDataset (<a class="reference internal" href="#mpol.datasets.GriddedDataset" title="mpol.datasets.GriddedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">GriddedDataset</span></code></a>): instance of the gridded dataset
k (int): the number of subpartitions of the dataset
q_edges (1D numpy array): an array of radial bin edges to set the dartboard cells in <span class="math notranslate nohighlight">\([\mathrm{k}\lambda]\)</span>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 12 log-linearly radial bins stretching from 0 to the <span class="math notranslate nohighlight">\(q_\mathrm{max}\)</span> represented by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.
phi_edges (1D numpy array): an array of azimuthal bin edges to set the dartboard cells in [radians]. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to 8 equal-spaced azimuthal bins stretched from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(\pi\)</span>.
seed (int): (optional) numpy random seed to use for the permutation, for reproducibility</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</dd></dl>

</section>
<section id="module-mpol.plot">
<span id="plotting"></span><h2>Plotting<a class="headerlink" href="#module-mpol.plot" title="Permalink to this headline">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mpol.plot.get_image_cmap_norm">
<span class="sig-prename descclassname"><span class="pre">mpol.plot.</span></span><span class="sig-name descname"><span class="pre">get_image_cmap_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stretch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'power'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">asinh_a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/plot.html#get_image_cmap_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.plot.get_image_cmap_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Get a colormap normalization to apply to an image.</p>
<dl class="simple">
<dt>image<span class="classifier">array</span></dt><dd><p>An image array.</p>
</dd>
<dt>stretch<span class="classifier">string, default = ‘power’</span></dt><dd><p>Transformation to apply to the colormap. ‘power’ is a
power law stretch; ‘asinh’ is an arcsinh stretch.</p>
</dd>
<dt>gamma<span class="classifier">float, default = 1.0</span></dt><dd><p>Index of power law normalization (see matplotlib.colors.PowerNorm).
gamma=1.0 yields a linear colormap.</p>
</dd>
<dt>asinh_a<span class="classifier">float, default = 0.02</span></dt><dd><p>Scale parameter for an asinh stretch.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.plot.vis_histogram_fig">
<span class="sig-prename descclassname"><span class="pre">mpol.plot.</span></span><span class="sig-name descname"><span class="pre">vis_histogram_fig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_quantity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'count'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_edges1d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_datapoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/plot.html#vis_histogram_fig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.plot.vis_histogram_fig" title="Permalink to this definition">#</a></dt>
<dd><p>Generate a figure with 1d and 2d histograms of (u,v)-plane coverage.
Histograms can show different data; see <cite>bin_quantity</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<cite>mpol.datasets.GriddedDataset</cite> object) – </p></li>
<li><p><strong>bin_quantity</strong> (<em>str</em><em> or </em><em>numpy.ndarray</em><em>, </em><em>default='count'</em>) – <dl class="simple">
<dt>Which quantity to bin:</dt><dd><ul>
<li><p>’count’ bins (u,v) points by their count</p></li>
<li><p>’weight’ bins points by the data weight (inherited from <cite>dataset</cite>)</p></li>
<li><p>’vis_real’ bins points by data Re(V)</p></li>
<li><p>’vis_imag’ bins points by data Im(V)</p></li>
<li><p>A user-supplied numpy.ndarray to be used as ‘weights’ in np.histogram</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>bin_label</strong> (<em>str</em><em>, </em><em>default=None</em>) – Label for 1d histogram y-axis and 2d histogram colorbar.</p></li>
<li><p><strong>q_edges</strong> (array, optional (default=None), unit=:math:[<cite>klambda</cite>]) – Radial bin edges for the 1d and 2d histogram. If <cite>None</cite>, defaults to
12 log-linearly radial bins over [0, 1.1 * maximum baseline in
<cite>dataset</cite>].</p></li>
<li><p><strong>phi_edges</strong> (<em>array</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em><em>, </em><em>unit=</em><em>[</em><em>rad</em><em>]</em>) – Azimuthal bin edges for the 2d histogram. If <cite>None</cite>, defaults to
16 bins over [-pi, pi]</p></li>
<li><p><strong>q_edges1d</strong> (array, optional (default=None), unit=:math:[<cite>klambda</cite>]) – Radial bin edges for a second 1d histogram. If <cite>None</cite>, defaults to
50 bins equispaced over [0, 1.1 * maximum baseline in <cite>dataset</cite>].</p></li>
<li><p><strong>show_datapoints</strong> (<em>bool</em><em>, </em><em>default = False</em>) – Whether to overplot the raw visibilities in <cite>dataset</cite> on the 2d
histogram.</p></li>
<li><p><strong>save_prefix</strong> (<em>string</em><em>, </em><em>default = None</em>) – Prefix for saved figure name. If None, the figure won’t be saved</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig</strong> (Matplotlib <cite>.Figure</cite> instance) – The generated figure</p></li>
<li><p><strong>axes</strong> (Matplotlib <cite>~.axes.Axes</cite> class) – Axes of the generated figure</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>No assumption or correction is made concerning whether the (u,v) distances
are projected or deprojected.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.plot.split_diagnostics_fig">
<span class="sig-prename descclassname"><span class="pre">mpol.plot.</span></span><span class="sig-name descname"><span class="pre">split_diagnostics_fig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splitter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/plot.html#split_diagnostics_fig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.plot.split_diagnostics_fig" title="Permalink to this definition">#</a></dt>
<dd><p>Generate a figure showing (u,v) coverage in train and test sets split from
a parent dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splitter</strong> (<cite>mpol.crossval.RandomCellSplitGridded</cite> object) – Iterator that returns a <cite>(train, test)</cite> pair of <a href="#id8"><span class="problematic" id="id9">`</span></a>GriddedDataset`s
for each iteration.</p></li>
<li><p><strong>channel</strong> (<em>int</em><em>, </em><em>default=0</em>) – Channel (of the datasets in <cite>splitter</cite>) to use to generate figure</p></li>
<li><p><strong>save_prefix</strong> (<em>string</em><em>, </em><em>default = None</em>) – Prefix for saved figure name. If None, the figure won’t be saved</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig</strong> (Matplotlib <cite>.Figure</cite> instance) – The generated figure</p></li>
<li><p><strong>axes</strong> (Matplotlib <cite>~.axes.Axes</cite> class) – Axes of the generated figure</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>No assumption or correction is made concerning whether the (u,v) distances
are projected or deprojected.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mpol.plot.train_diagnostics_fig">
<span class="sig-prename descclassname"><span class="pre">mpol.plot.</span></span><span class="sig-name descname"><span class="pre">train_diagnostics_fig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">losses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mpol/plot.html#train_diagnostics_fig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mpol.plot.train_diagnostics_fig" title="Permalink to this definition">#</a></dt>
<dd><p>Figure for model diagnostics during an optimization loop. For a <cite>model</cite> in
a given state, plots the current:</p>
<blockquote>
<div><ul class="simple">
<li><p>model image (both linear and arcsinh colormap normalization)</p></li>
<li><p>gradient image</p></li>
<li><p>loss function</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<cite>torch.nn.Module</cite> object) – A neural network; instance of the <cite>mpol.precomposed.SimpleNet</cite> class.</p></li>
<li><p><strong>losses</strong> (<em>list</em>) – Loss value at each epoch in the training loop</p></li>
<li><p><strong>train_state</strong> (<em>dict</em><em>, </em><em>default=None</em>) – Dictionary containing current training parameter values. Used for
figure title and savefile name.</p></li>
<li><p><strong>channel</strong> (<em>int</em><em>, </em><em>default=0</em>) – Channel (of the datasets in <cite>splitter</cite>) to use to generate figure</p></li>
<li><p><strong>save_prefix</strong> (<em>string</em><em>, </em><em>default = None</em>) – Prefix for saved figure name. If None, the figure won’t be saved</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig</strong> (Matplotlib <cite>.Figure</cite> instance) – The generated figure</p></li>
<li><p><strong>axes</strong> (Matplotlib <cite>~.axes.Axes</cite> class) – Axes of the generated figure</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="developer-documentation.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Developer Documentation</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="ci-tutorials/PyTorch.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Introduction to PyTorch: Tensors and Gradient Descent</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Ian Czekala<br/>
  
      &copy; Copyright 2019-22, Ian Czekala.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>